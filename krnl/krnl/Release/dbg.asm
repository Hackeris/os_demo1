; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	i:\os\10\a\krnl\krnl\dbg.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?cursor_x@@3EA					; cursor_x
PUBLIC	?cursor_y@@3EA					; cursor_y
PUBLIC	?_color@@3EA					; _color
PUBLIC	?video_memory@@3PAGA				; video_memory
_BSS	SEGMENT
?cursor_x@@3EA DB 01H DUP (?)				; cursor_x
?cursor_y@@3EA DB 01H DUP (?)				; cursor_y
_BSS	ENDS
_DATA	SEGMENT
?_color@@3EA DB	07H					; _color
	ORG $+3
?video_memory@@3PAGA DD 0b8000H				; video_memory
_DATA	ENDS
PUBLIC	?DbgSetColor@@YAXE@Z				; DbgSetColor
; Function compile flags: /Ogtpy
; File i:\os\10\a\krnl\krnl\dbg.cpp
;	COMDAT ?DbgSetColor@@YAXE@Z
_TEXT	SEGMENT
_color$ = 8						; size = 1
?DbgSetColor@@YAXE@Z PROC				; DbgSetColor, COMDAT

; 127  : 	_color = color;

	mov	al, BYTE PTR _color$[esp-4]
	mov	BYTE PTR ?_color@@3EA, al		; _color

; 128  : }

	ret	0
?DbgSetColor@@YAXE@Z ENDP				; DbgSetColor
_TEXT	ENDS
PUBLIC	?DbgUpdateCur@@YAXXZ				; DbgUpdateCur
; Function compile flags: /Ogtpy
;	COMDAT ?DbgUpdateCur@@YAXXZ
_TEXT	SEGMENT
?DbgUpdateCur@@YAXXZ PROC				; DbgUpdateCur, COMDAT

; 156  : {

	push	ebx
	push	esi
	push	edi

; 157  : 	// the x is in the bl
; 158  : 	// the y is in the bh
; 159  : 	// write y*80+x to CRT data register
; 160  : 	__asm{
; 161  : 		pusha

	pusha

; 162  : 		mov bl,[cursor_x]

	mov	bl, BYTE PTR ?cursor_x@@3EA		; cursor_x

; 163  : 		mov bh,[cursor_y]

	mov	bh, BYTE PTR ?cursor_y@@3EA		; cursor_y

; 164  : 		xor	eax,eax

	xor	eax, eax

; 165  : 		mov ecx,80

	mov	ecx, 80					; 00000050H

; 166  : 		mov al,bh

	mov	al, bh

; 167  : 		mul	ecx

	mul	ecx

; 168  : 		add	al,bl

	add	al, bl

; 169  : 		mov ebx,eax				// ebx = y*80+x

	mov	ebx, eax

; 170  : 
; 171  : 		mov al,0x0f

	mov	al, 15					; 0000000fH

; 172  : 		mov dx,0x03d4

	mov	dx, 980					; 000003d4H

; 173  : 		out	dx,al

	out	dx, al

; 174  : 		
; 175  : 		mov al,bl				//high byte

	mov	al, bl

; 176  : 		mov dx,0x03d5

	mov	dx, 981					; 000003d5H

; 177  : 		out	dx,al

	out	dx, al

; 178  : 
; 179  : 		xor eax,eax

	xor	eax, eax

; 180  : 
; 181  : 		mov al,0x0e

	mov	al, 14					; 0000000eH

; 182  : 		mov dx,0x03d4

	mov	dx, 980					; 000003d4H

; 183  : 		out	dx,al

	out	dx, al

; 184  : 
; 185  : 		mov al,bh				//low byte

	mov	al, bh

; 186  : 		mov dx,0x03d5

	mov	dx, 981					; 000003d5H

; 187  : 		out	dx,al

	out	dx, al

; 188  : 
; 189  : 		popa

	popa

; 190  : 	}
; 191  : }

	pop	edi
	pop	esi
	pop	ebx
	ret	0
?DbgUpdateCur@@YAXXZ ENDP				; DbgUpdateCur
_TEXT	ENDS
PUBLIC	?putc@@YAXE@Z					; putc
; Function compile flags: /Ogtpy
;	COMDAT ?putc@@YAXE@Z
_TEXT	SEGMENT
_c$ = 8							; size = 1
?putc@@YAXE@Z PROC					; putc, COMDAT

; 15   : 	uint16_t attribute=_color<<8;

	xor	eax, eax
	mov	ah, BYTE PTR ?_color@@3EA		; _color
	push	ebx
	push	esi
	push	edi
	movzx	ecx, ax

; 16   : 	if(c == 0x08 && cursor_x){

	mov	al, BYTE PTR _c$[esp+8]
	cmp	al, 8
	jne	SHORT $LN10@putc
	mov	al, BYTE PTR ?cursor_x@@3EA		; cursor_x
	test	al, al
	je	SHORT $LN2@putc

; 17   : 		cursor_x--;

	add	al, 255					; 000000ffH
	mov	BYTE PTR ?cursor_x@@3EA, al		; cursor_x
	jmp	SHORT $LN2@putc
$LN10@putc:

; 18   : 	}
; 19   : 	else if(c == 0x09){

	cmp	al, 9
	jne	SHORT $LN8@putc

; 20   : 		cursor_x=(cursor_x+8)&~(8-1);

	mov	al, BYTE PTR ?cursor_x@@3EA		; cursor_x
	add	al, 8
	and	al, 248					; 000000f8H
	mov	BYTE PTR ?cursor_x@@3EA, al		; cursor_x
	jmp	SHORT $LN2@putc
$LN8@putc:

; 21   : 	}
; 22   : 	else if(c == '\r'){

	cmp	al, 13					; 0000000dH

; 23   : 		cursor_x=0;

	je	SHORT $LN16@putc

; 24   : 	}
; 25   : 	else if(c == '\n'){

	cmp	al, 10					; 0000000aH

; 26   : 		cursor_x=0;
; 27   : 		cursor_y++;

	je	SHORT $LN17@putc

; 28   : 	}
; 29   : 
; 30   : 	else if(c >= ' '){

	cmp	al, 32					; 00000020H
	jb	SHORT $LN15@putc

; 31   : 		uint16_t* location = video_memory + (cursor_y*80 + cursor_x);
; 32   : 		*location= c | attribute;

	movzx	dx, al
	movzx	eax, BYTE PTR ?cursor_y@@3EA		; cursor_y
	or	dx, cx
	movzx	ecx, BYTE PTR ?cursor_x@@3EA		; cursor_x
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 4
	add	eax, ecx
	mov	ecx, DWORD PTR ?video_memory@@3PAGA	; video_memory
	mov	WORD PTR [ecx+eax*2], dx

; 33   : 		cursor_x++;

	mov	al, BYTE PTR ?cursor_x@@3EA		; cursor_x
	add	al, 1
	mov	BYTE PTR ?cursor_x@@3EA, al		; cursor_x
	jmp	SHORT $LN2@putc
$LN15@putc:
	mov	al, BYTE PTR ?cursor_x@@3EA		; cursor_x
$LN2@putc:

; 34   : 	}
; 35   : 
; 36   : 	if(cursor_x >= 80){

	cmp	al, 80					; 00000050H
	jb	SHORT $LN1@putc
$LN17@putc:

; 38   : 		cursor_y ++;

	add	BYTE PTR ?cursor_y@@3EA, 1		; cursor_y
$LN16@putc:

; 37   : 		cursor_x = 0;

	mov	BYTE PTR ?cursor_x@@3EA, 0		; cursor_x
$LN1@putc:

; 39   : 	}
; 40   : 	DbgUpdateCur();

	pusha
	mov	bl, BYTE PTR ?cursor_x@@3EA		; cursor_x
	mov	bh, BYTE PTR ?cursor_y@@3EA		; cursor_y
	xor	eax, eax
	mov	ecx, 80					; 00000050H
	mov	al, bh
	mul	ecx
	add	al, bl
	mov	ebx, eax
	mov	al, 15					; 0000000fH
	mov	dx, 980					; 000003d4H
	out	dx, al
	mov	al, bl
	mov	dx, 981					; 000003d5H
	out	dx, al
	xor	eax, eax
	mov	al, 14					; 0000000eH
	mov	dx, 980					; 000003d4H
	out	dx, al
	mov	al, bh
	mov	dx, 981					; 000003d5H
	out	dx, al
	popa

; 41   : }

	pop	edi
	pop	esi
	pop	ebx
	ret	0
?putc@@YAXE@Z ENDP					; putc
_TEXT	ENDS
PUBLIC	?puts@@YAXPAD@Z					; puts
; Function compile flags: /Ogtpy
;	COMDAT ?puts@@YAXPAD@Z
_TEXT	SEGMENT
_str$ = 8						; size = 4
?puts@@YAXPAD@Z PROC					; puts, COMDAT

; 44   : {

	push	esi

; 45   : 	if(!str)

	mov	esi, DWORD PTR _str$[esp]
	test	esi, esi
	je	SHORT $LN1@puts

; 46   : 		return;
; 47   : 	while(*str){

	movzx	eax, BYTE PTR [esi]
	test	al, al
	je	SHORT $LN1@puts
$LL2@puts:

; 48   : 		putc(*str);

	push	eax
	call	?putc@@YAXE@Z				; putc
	mov	al, BYTE PTR [esi+1]

; 49   : 		str++;

	add	esi, 1
	add	esp, 4
	test	al, al
	jne	SHORT $LL2@puts
$LN1@puts:
	pop	esi

; 50   : 	}
; 51   : }

	ret	0
?puts@@YAXPAD@Z ENDP					; puts
_TEXT	ENDS
PUBLIC	?DbgPrintf@@YAHPBDZZ				; DbgPrintf
EXTRN	?itoa_s@@YAXHIPAD@Z:PROC			; itoa_s
EXTRN	?strcpy@@YAPADPADPBD@Z:PROC			; strcpy
EXTRN	?strlen@@YAIPBD@Z:PROC				; strlen
; Function compile flags: /Ogtpy
;	COMDAT ?DbgPrintf@@YAHPBDZZ
_TEXT	SEGMENT
_str$3051 = -64						; size = 32
_str$3041 = -64						; size = 32
_str$3030 = -64						; size = 64
_str$ = 8						; size = 4
?DbgPrintf@@YAHPBDZZ PROC				; DbgPrintf, COMDAT

; 55   : {

	sub	esp, 64					; 00000040H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 58   : 	size_t i;
; 59   : 	for (i=0; i<strlen(str);i++) {

	mov	edi, DWORD PTR _str$[esp+76]
	push	edi
	xor	ebx, ebx
	xor	ebp, ebp
	call	?strlen@@YAIPBD@Z			; strlen
	add	esp, 4
	test	eax, eax
	jbe	$LN12@DbgPrintf

; 56   : 	va_list		args;
; 57   : 	va_start (args, str);

	lea	esi, DWORD PTR _str$[esp+76]
$LL14@DbgPrintf:

; 60   : 
; 61   : 		switch (str[i]) {

	movzx	eax, BYTE PTR [edi+ebp]
	cmp	al, 37					; 00000025H
	je	SHORT $LN9@DbgPrintf

; 110  : 				}
; 111  : 
; 112  : 				break;
; 113  : 
; 114  : 			default:
; 115  : 				putc (str[i]);

	push	eax
	call	?putc@@YAXE@Z				; putc
	add	esp, 4

; 116  : 				break;

	jmp	$LN13@DbgPrintf
$LN9@DbgPrintf:

; 62   : 
; 63   : 			case '%':
; 64   : 
; 65   : 				switch (str[i+1]) {

	movsx	eax, BYTE PTR [edi+ebp+1]
	add	eax, -88				; ffffffa8H
	cmp	eax, 32					; 00000020H
	ja	$LN2@DbgPrintf
	movzx	eax, BYTE PTR $LN33@DbgPrintf[eax]
	jmp	DWORD PTR $LN35@DbgPrintf[eax*4]
$LN6@DbgPrintf:

; 66   : 
; 67   : 					/*** characters ***/
; 68   : 					case 'c': {
; 69   : 						char c = va_arg (args, char);
; 70   : 						putc (c);

	movzx	ecx, BYTE PTR [esi+4]
	add	esi, 4
	push	ecx
	call	?putc@@YAXE@Z				; putc
	add	esp, 4

; 71   : 						i++;		// go to next character
; 72   : 						break;

	jmp	$LN34@DbgPrintf
$LN5@DbgPrintf:

; 73   : 					}
; 74   : 
; 75   : 					/*** address of ***/
; 76   : 					case 's': {
; 77   : 						int c = (int&) va_arg (args, char);
; 78   : 						char str[64];
; 79   : 						strcpy (str,(const char*)c);

	mov	edx, DWORD PTR [esi+4]
	add	esi, 4
	push	edx
	lea	eax, DWORD PTR _str$3030[esp+84]
	push	eax
	call	?strcpy@@YAPADPADPBD@Z			; strcpy

; 80   : 						puts (str);

	lea	ecx, DWORD PTR _str$3030[esp+88]
	push	ecx
	call	?puts@@YAXPAD@Z				; puts
	add	esp, 12					; 0000000cH

; 81   : 						i++;		// go to next character
; 82   : 						break;

	jmp	$LN34@DbgPrintf
$LN4@DbgPrintf:

; 83   : 					}
; 84   : 
; 85   : 					/*** integers ***/
; 86   : 					case 'd':
; 87   : 					case 'i': {
; 88   : 						int c = va_arg (args, int);
; 89   : 						char str[32]={0};

	xor	eax, eax

; 90   : 						itoa_s (c, 10, str);

	lea	edx, DWORD PTR _str$3041[esp+80]
	push	edx
	add	esi, 4
	mov	DWORD PTR _str$3041[esp+85], eax
	mov	DWORD PTR _str$3041[esp+89], eax
	mov	DWORD PTR _str$3041[esp+93], eax
	mov	DWORD PTR _str$3041[esp+97], eax
	mov	DWORD PTR _str$3041[esp+101], eax
	mov	DWORD PTR _str$3041[esp+105], eax
	mov	DWORD PTR _str$3041[esp+109], eax
	mov	WORD PTR _str$3041[esp+113], ax
	mov	BYTE PTR _str$3041[esp+115], al
	mov	eax, DWORD PTR [esi]
	push	10					; 0000000aH
	push	eax
	mov	BYTE PTR _str$3041[esp+92], bl
	call	?itoa_s@@YAXHIPAD@Z			; itoa_s

; 91   : 						puts (str);

	movzx	eax, BYTE PTR _str$3041[esp+92]
	add	esp, 12					; 0000000cH
	cmp	al, bl
	lea	edi, DWORD PTR _str$3041[esp+80]
	je	SHORT $LN22@DbgPrintf
	npad	2
$LL18@DbgPrintf:
	push	eax
	call	?putc@@YAXE@Z				; putc
	mov	al, BYTE PTR [edi+1]
	add	edi, 1
	add	esp, 4
	cmp	al, bl
	jne	SHORT $LL18@DbgPrintf

; 92   : 						i++;		// go to next character
; 93   : 						break;

	jmp	SHORT $LN22@DbgPrintf
$LN3@DbgPrintf:

; 94   : 					}
; 95   : 
; 96   : 					/*** display in hex ***/
; 97   : 					case 'X':
; 98   : 					case 'x': {
; 99   : 						int c = va_arg (args, int);
; 100  : 						char str[32]={0};
; 101  : 						itoa_s (c,16,str);

	mov	edx, DWORD PTR [esi+4]
	xor	eax, eax
	lea	ecx, DWORD PTR _str$3051[esp+80]
	push	ecx
	add	esi, 4
	push	16					; 00000010H
	push	edx
	mov	BYTE PTR _str$3051[esp+92], bl
	mov	DWORD PTR _str$3051[esp+93], eax
	mov	DWORD PTR _str$3051[esp+97], eax
	mov	DWORD PTR _str$3051[esp+101], eax
	mov	DWORD PTR _str$3051[esp+105], eax
	mov	DWORD PTR _str$3051[esp+109], eax
	mov	DWORD PTR _str$3051[esp+113], eax
	mov	DWORD PTR _str$3051[esp+117], eax
	mov	WORD PTR _str$3051[esp+121], ax
	mov	BYTE PTR _str$3051[esp+123], al
	call	?itoa_s@@YAXHIPAD@Z			; itoa_s

; 102  : 						puts (str);

	movzx	eax, BYTE PTR _str$3051[esp+92]
	add	esp, 12					; 0000000cH
	cmp	al, bl
	lea	edi, DWORD PTR _str$3051[esp+80]
	je	SHORT $LN22@DbgPrintf
$LL23@DbgPrintf:
	push	eax
	call	?putc@@YAXE@Z				; putc
	mov	al, BYTE PTR [edi+1]
	add	edi, 1
	add	esp, 4
	cmp	al, bl
	jne	SHORT $LL23@DbgPrintf
$LN22@DbgPrintf:

; 103  : 						i++;		// go to next character

	mov	edi, DWORD PTR _str$[esp+76]
$LN34@DbgPrintf:
	add	ebp, 1
$LN13@DbgPrintf:

; 58   : 	size_t i;
; 59   : 	for (i=0; i<strlen(str);i++) {

	push	edi
	add	ebp, 1
	call	?strlen@@YAIPBD@Z			; strlen
	add	esp, 4
	cmp	ebp, eax
	jb	$LL14@DbgPrintf
$LN12@DbgPrintf:
	pop	edi
	pop	esi

; 117  : 		}
; 118  : 
; 119  : 	}
; 120  : 
; 121  : 	va_end (args);
; 122  : 	return i;

	mov	eax, ebp
	pop	ebp
	pop	ebx

; 123  : }

	add	esp, 64					; 00000040H
	ret	0
$LN2@DbgPrintf:
	pop	edi
	pop	esi
	pop	ebp

; 104  : 						break;
; 105  : 					}
; 106  : 
; 107  : 					default:
; 108  : 						va_end (args);
; 109  : 						return 1;

	mov	eax, 1
	pop	ebx

; 123  : }

	add	esp, 64					; 00000040H
	ret	0
$LN35@DbgPrintf:
	DD	$LN3@DbgPrintf
	DD	$LN6@DbgPrintf
	DD	$LN4@DbgPrintf
	DD	$LN5@DbgPrintf
	DD	$LN2@DbgPrintf
$LN33@DbgPrintf:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
?DbgPrintf@@YAHPBDZZ ENDP				; DbgPrintf
_TEXT	ENDS
PUBLIC	?DbgGotoXY@@YAXEE@Z				; DbgGotoXY
; Function compile flags: /Ogtpy
;	COMDAT ?DbgGotoXY@@YAXEE@Z
_TEXT	SEGMENT
_x$ = 8							; size = 1
_y$ = 12						; size = 1
?DbgGotoXY@@YAXEE@Z PROC				; DbgGotoXY, COMDAT

; 146  : 	if (cursor_x <= 80)

	cmp	BYTE PTR ?cursor_x@@3EA, 80		; cursor_x, 00000050H
	push	ebx
	push	esi
	push	edi
	ja	SHORT $LN2@DbgGotoXY

; 147  : 	    cursor_x = x;

	mov	al, BYTE PTR _x$[esp+8]
	mov	BYTE PTR ?cursor_x@@3EA, al		; cursor_x
$LN2@DbgGotoXY:

; 148  : 
; 149  : 	if (cursor_y <= 25)

	cmp	BYTE PTR ?cursor_y@@3EA, 25		; cursor_y, 00000019H
	ja	SHORT $LN1@DbgGotoXY

; 150  : 	    cursor_y = y;

	mov	cl, BYTE PTR _y$[esp+8]
	mov	BYTE PTR ?cursor_y@@3EA, cl		; cursor_y
$LN1@DbgGotoXY:

; 151  : 
; 152  : 	DbgUpdateCur();

	pusha
	mov	bl, BYTE PTR ?cursor_x@@3EA		; cursor_x
	mov	bh, BYTE PTR ?cursor_y@@3EA		; cursor_y
	xor	eax, eax
	mov	ecx, 80					; 00000050H
	mov	al, bh
	mul	ecx
	add	al, bl
	mov	ebx, eax
	mov	al, 15					; 0000000fH
	mov	dx, 980					; 000003d4H
	out	dx, al
	mov	al, bl
	mov	dx, 981					; 000003d5H
	out	dx, al
	xor	eax, eax
	mov	al, 14					; 0000000eH
	mov	dx, 980					; 000003d4H
	out	dx, al
	mov	al, bh
	mov	dx, 981					; 000003d5H
	out	dx, al
	popa

; 153  : }

	pop	edi
	pop	esi
	pop	ebx
	ret	0
?DbgGotoXY@@YAXEE@Z ENDP				; DbgGotoXY
_TEXT	ENDS
PUBLIC	??_C@_02NJNOFBBI@?$CFx?$AA@			; `string'
PUBLIC	?DbgPrintMem@@YAXPAXI@Z				; DbgPrintMem
;	COMDAT ??_C@_02NJNOFBBI@?$CFx?$AA@
CONST	SEGMENT
??_C@_02NJNOFBBI@?$CFx?$AA@ DB '%x', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?DbgPrintMem@@YAXPAXI@Z
_TEXT	SEGMENT
_src$ = 8						; size = 4
_len$ = 12						; size = 4
?DbgPrintMem@@YAXPAXI@Z PROC				; DbgPrintMem, COMDAT

; 194  : {

	push	esi
	push	edi

; 195  : 	uint8_t* p = (uint8_t*)src;
; 196  : 	uint32_t i;
; 197  : 	for(i=0;i<len;i++){

	mov	edi, DWORD PTR _len$[esp+4]
	xor	esi, esi
	test	edi, edi
	jbe	SHORT $LN1@DbgPrintMe
	push	ebx
	mov	ebx, DWORD PTR _src$[esp+8]
$LL3@DbgPrintMe:

; 198  : 		DbgPrintf("%x",p[i]);

	movzx	eax, BYTE PTR [esi+ebx]
	push	eax
	push	OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	call	?DbgPrintf@@YAHPBDZZ			; DbgPrintf
	add	esi, 1
	add	esp, 8
	cmp	esi, edi
	jb	SHORT $LL3@DbgPrintMe
	pop	ebx
$LN1@DbgPrintMe:
	pop	edi
	pop	esi

; 199  : 	}
; 200  : }

	ret	0
?DbgPrintMem@@YAXPAXI@Z ENDP				; DbgPrintMem
_TEXT	ENDS
PUBLIC	?DbgCls@@YAXE@Z					; DbgCls
; Function compile flags: /Ogtpy
;	COMDAT ?DbgCls@@YAXE@Z
_TEXT	SEGMENT
_color$ = 8						; size = 1
?DbgCls@@YAXE@Z PROC					; DbgCls, COMDAT

; 132  : 	unsigned long ulBase=0xb8000;

	mov	dl, BYTE PTR _color$[esp-4]
	mov	eax, 753664				; 000b8000H
	mov	ecx, 2000				; 000007d0H
	npad	2
$LL2@DbgCls:

; 133  : 	unsigned long i=0;
; 134  : 	while(i<80*25){
; 135  : 		*(char*)ulBase=' ';

	mov	BYTE PTR [eax], 32			; 00000020H

; 136  : 		ulBase++;

	add	eax, 1

; 137  : 		*(char*)ulBase=color;

	mov	BYTE PTR [eax], dl

; 138  : 		ulBase++;

	add	eax, 1
	sub	ecx, 1
	jne	SHORT $LL2@DbgCls

; 139  : 		i++;
; 140  : 	}
; 141  : 	DbgGotoXY(0,0);

	push	ecx
	push	ecx
	call	?DbgGotoXY@@YAXEE@Z			; DbgGotoXY
	add	esp, 8

; 142  : }

	ret	0
?DbgCls@@YAXE@Z ENDP					; DbgCls
_TEXT	ENDS
END
