; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	i:\os\09\g\krnl\krnl\mm.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?do_fork@@YAHPAU_tagMESSAGE@@@Z			; do_fork
EXTRN	?send_recv@@YAHHHPAU_tagMESSAGE@@@Z:PROC	; send_recv
EXTRN	?ldt_set_descriptor@@YAXPAU_tagLDT_DESCRIPTOR@@IIG@Z:PROC ; ldt_set_descriptor
EXTRN	?pmmgr_alloc_blocks@@YAPAXI@Z:PROC		; pmmgr_alloc_blocks
EXTRN	?memcpy@@YAPAXPAXPBXI@Z:PROC			; memcpy
EXTRN	?proc_table@@3PAU_tagPROC@@A:BYTE		; proc_table
; Function compile flags: /Ogtpy
; File i:\os\09\g\krnl\krnl\mm.cpp
;	COMDAT ?do_fork@@YAHPAU_tagMESSAGE@@@Z
_TEXT	SEGMENT
_child_ldt_sel$ = -52					; size = 2
_caller_t_size$ = -52					; size = 4
_m$ = -48						; size = 48
_msg$ = 8						; size = 4
?do_fork@@YAHPAU_tagMESSAGE@@@Z PROC			; do_fork, COMDAT

; 13   : {

	sub	esp, 52					; 00000034H
	push	ebp
	push	esi

; 14   : 	PROCESS* p = proc_table;

	mov	esi, OFFSET ?proc_table@@3PAU_tagPROC@@A ; proc_table

; 15   : 	int i ;
; 16   : 	for(i = 0; i < NR_TASKS+NR_PROCS; i++,p++){

	xor	ebp, ebp
	mov	eax, 8
$LL5@do_fork:

; 17   : 		if(p->p_flags == FREE_SLOT)

	cmp	DWORD PTR [esi+118], eax
	je	SHORT $LN16@do_fork
	add	esi, 182				; 000000b6H
	cmp	DWORD PTR [esi+118], eax
	je	SHORT $LN11@do_fork
	add	esi, 182				; 000000b6H
	cmp	DWORD PTR [esi+118], eax
	je	SHORT $LN12@do_fork
	add	esi, 182				; 000000b6H
	cmp	DWORD PTR [esi+118], eax
	je	SHORT $LN13@do_fork
	add	esi, 182				; 000000b6H
	cmp	DWORD PTR [esi+118], eax
	je	SHORT $LN14@do_fork
	add	esi, 182				; 000000b6H
	cmp	DWORD PTR [esi+118], eax
	je	SHORT $LN15@do_fork
	add	ebp, 6
	add	esi, 182				; 000000b6H
	cmp	ebp, 36					; 00000024H
	jl	SHORT $LL5@do_fork
	jmp	SHORT $LN16@do_fork
$LN11@do_fork:
	add	ebp, 1
	jmp	SHORT $LN16@do_fork
$LN12@do_fork:
	add	ebp, 2
	jmp	SHORT $LN16@do_fork
$LN13@do_fork:
	add	ebp, 3
	jmp	SHORT $LN16@do_fork
$LN14@do_fork:
	add	ebp, 4
	jmp	SHORT $LN16@do_fork
$LN15@do_fork:
	add	ebp, 5
$LN16@do_fork:

; 18   : 			break;
; 19   : 	}
; 20   : 
; 21   : 	int child_pid = i;
; 22   : 	if(child_pid == NR_TASKS + NR_PROCS)

	cmp	ebp, 36					; 00000024H
	jne	SHORT $LN1@do_fork
	pop	esi

; 23   : 		return -1;

	or	eax, -1
	pop	ebp

; 71   : }

	add	esp, 52					; 00000034H
	ret	0
$LN1@do_fork:

; 24   : 
; 25   : 	//	duplicate the process table
; 26   : 	int pid = msg->source;

	mov	eax, DWORD PTR _msg$[esp+56]

; 27   : 	uint16_t child_ldt_sel = p->ldt_sel;

	movzx	ecx, WORD PTR [esi+72]
	push	ebx
	mov	ebx, DWORD PTR [eax]
	push	edi

; 28   : 	//*p = proc_table[pid];
; 29   : 	memcpy(p,&proc_table[pid],sizeof(PROCESS));

	mov	edi, ebx
	imul	edi, 182				; 000000b6H
	push	182					; 000000b6H
	lea	edx, DWORD PTR ?proc_table@@3PAU_tagPROC@@A[edi]
	push	edx
	push	esi
	mov	DWORD PTR _child_ldt_sel$[esp+80], ecx
	call	?memcpy@@YAPAXPAXPBXI@Z			; memcpy

; 30   : 	p->ldt_sel = child_ldt_sel;

	mov	ax, WORD PTR _child_ldt_sel$[esp+80]
	mov	WORD PTR [esi+72], ax

; 31   : 	p->p_parent = pid;

	mov	DWORD PTR [esi+178], ebx

; 32   : 	p->nr_tty = proc_table[pid].nr_tty;

	mov	ecx, DWORD PTR ?proc_table@@3PAU_tagPROC@@A[edi+114]
	mov	DWORD PTR [esi+114], ecx

; 33   : 
; 34   : 	LDT_DESCRIPTOR* ppd = &proc_table[pid].ldts[0];	//code ldt
; 35   : 	//	base of code seg, in bytes
; 36   : 	int caller_t_base = ppd->baseHi << 24 | ppd->baseMid << 16 | ppd->baseLo;
; 37   : 	//	limit
; 38   : 	int caller_t_limit = (ppd->grand & 0x0f) << 16 | ppd->limit;

	mov	al, BYTE PTR ?proc_table@@3PAU_tagPROC@@A[edi+80]
	movzx	edx, WORD PTR ?proc_table@@3PAU_tagPROC@@A[edi+76]
	xor	ebx, ebx
	mov	bh, BYTE PTR ?proc_table@@3PAU_tagPROC@@A[edi+81]

; 39   : 
; 40   : 	int caller_t_size = (caller_t_limit + 1)*
; 41   : 		((ppd->grand & (DA_LIMIT_4K >> 8)) ? 4096 : 1);

	movzx	ecx, al
	and	ecx, 15					; 0000000fH
	shl	ecx, 16					; 00000010H
	and	al, 128					; 00000080H
	mov	bl, BYTE PTR ?proc_table@@3PAU_tagPROC@@A[edi+78]

; 42   : 
; 43   : 	//	data
; 44   : 	ppd = &proc_table[pid].ldts[1];
; 45   : 	int caller_d_s_base =  ppd->baseHi << 24 | ppd->baseMid << 16 | ppd->baseLo;
; 46   : 	int caller_d_s_limit = (ppd->grand & 0x0f) << 16 | ppd->limit;
; 47   : 	int caller_d_s_size = (caller_d_s_limit + 1)*
; 48   : 		((ppd->grand & (DA_LIMIT_4K >> 8)) ? 4096 : 1);
; 49   : 	//	base of child proc share the same space
; 50   : 	int child_base = (int)pmmgr_alloc_blocks(256);

	push	256					; 00000100H
	shl	ebx, 16					; 00000010H
	or	ebx, edx
	movzx	edx, WORD PTR ?proc_table@@3PAU_tagPROC@@A[edi+74]
	or	ecx, edx
	add	ecx, 1
	neg	al
	sbb	eax, eax
	and	eax, 4095				; 00000fffH
	add	eax, 1
	imul	ecx, eax
	mov	DWORD PTR _caller_t_size$[esp+84], ecx
	call	?pmmgr_alloc_blocks@@YAPAXI@Z		; pmmgr_alloc_blocks
	mov	edi, eax

; 51   : 	memcpy((void*)child_base,(void*)caller_t_base,caller_t_size);

	mov	eax, DWORD PTR _caller_t_size$[esp+84]
	push	eax
	push	ebx
	push	edi
	call	?memcpy@@YAPAXPAXPBXI@Z			; memcpy

; 52   : 
; 53   : 	//	child's ldt
; 54   : 	ldt_set_descriptor(&p->ldts[0],child_base,
; 55   : 		(PROC_IMAGE_SIZE_DEFAULT - 1) >> LIMIT_4K_SHIFT,
; 56   : 		DA_LIMIT_4K | DA_32 | DA_C | PRIVILEGE_USER << 5);

	push	49400					; 0000c0f8H
	push	255					; 000000ffH
	lea	ecx, DWORD PTR [esi+74]
	push	edi
	push	ecx
	call	?ldt_set_descriptor@@YAXPAU_tagLDT_DESCRIPTOR@@IIG@Z ; ldt_set_descriptor

; 57   : 	ldt_set_descriptor(&p->ldts[1],child_base,
; 58   : 		(PROC_IMAGE_SIZE_DEFAULT - 1) >> LIMIT_4K_SHIFT,
; 59   : 		DA_LIMIT_4K | DA_32 | DA_DRW | PRIVILEGE_USER << 5);

	push	49394					; 0000c0f2H
	push	255					; 000000ffH
	push	edi
	add	esi, 82					; 00000052H
	push	esi
	call	?ldt_set_descriptor@@YAXPAU_tagLDT_DESCRIPTOR@@IIG@Z ; ldt_set_descriptor

; 60   : 
; 61   : 	//	return
; 62   : 	msg->PID = child_pid;

	mov	edx, DWORD PTR _msg$[esp+124]

; 63   : 
; 64   : 	MESSAGE m;
; 65   : 	m.type = SYSCALL_RET;
; 66   : 	m.RETVAL = 0;

	xor	eax, eax
	mov	DWORD PTR _m$[esp+136], eax

; 67   : 	m.PID = 0;

	mov	DWORD PTR _m$[esp+140], eax

; 68   : 	send_recv(SEND,child_pid,&m);

	lea	eax, DWORD PTR _m$[esp+128]
	push	eax
	push	ebp
	push	1
	mov	DWORD PTR [edx+12], ebp
	mov	DWORD PTR _m$[esp+144], 2
	call	?send_recv@@YAHHHPAU_tagMESSAGE@@@Z	; send_recv
	add	esp, 72					; 00000048H
	pop	edi
	pop	ebx
	pop	esi

; 69   : 
; 70   : 	return 0;

	xor	eax, eax
	pop	ebp

; 71   : }

	add	esp, 52					; 00000034H
	ret	0
?do_fork@@YAHPAU_tagMESSAGE@@@Z ENDP			; do_fork
_TEXT	ENDS
END
