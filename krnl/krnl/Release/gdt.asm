; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	i:\os\10\a\krnl\krnl\gdt.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?_gdt@@3PAUgdt_descriptor@@A			; _gdt
PUBLIC	?_gdtr@@3Ugdtr@@A				; _gdtr
_BSS	SEGMENT
?_gdt@@3PAUgdt_descriptor@@A DQ 0100H DUP (?)		; _gdt
?_gdtr@@3Ugdtr@@A DF 01H DUP (?)			; _gdtr
_BSS	ENDS
PUBLIC	?gdt_set_descriptor@@YAXIIIEE@Z			; gdt_set_descriptor
EXTRN	?memset@@YAPAXPAXDI@Z:PROC			; memset
; Function compile flags: /Ogtpy
; File i:\os\10\a\krnl\krnl\gdt.cpp
;	COMDAT ?gdt_set_descriptor@@YAXIIIEE@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
_base$ = 12						; size = 4
_limit$ = 16						; size = 4
_access$ = 20						; size = 1
_grand$ = 24						; size = 1
?gdt_set_descriptor@@YAXIIIEE@Z PROC			; gdt_set_descriptor, COMDAT

; 11   : {

	push	esi

; 12   : 	if(i > MAX_DESCRIPTORS){

	mov	esi, DWORD PTR _i$[esp]
	cmp	esi, 256				; 00000100H
	ja	SHORT $LN2@gdt_set_de
	push	edi

; 13   : 		return ;
; 14   : 	}
; 15   : 
; 16   : 	memset((void*)&_gdt[i],0,sizeof(gdt_descriptor));

	push	8
	lea	edi, DWORD PTR ?_gdt@@3PAUgdt_descriptor@@A[esi*8]
	push	0
	push	edi
	call	?memset@@YAPAXPAXDI@Z			; memset

; 17   : 
; 18   : 	_gdt[i].baseLo	= (uint16_t)(base & 0xffff);

	mov	eax, DWORD PTR _base$[esp+16]

; 19   : 	_gdt[i].baseMid	= (uint8_t)((base >> 16) & 0xff);
; 20   : 	_gdt[i].baseHi	= (uint8_t)((base >> 24) & 0xff);
; 21   : 	_gdt[i].limit	= (uint16_t)(limit & 0xffff);
; 22   : 
; 23   : 	_gdt[i].flags = access;

	mov	dl, BYTE PTR _access$[esp+16]
	mov	ecx, eax
	mov	WORD PTR ?_gdt@@3PAUgdt_descriptor@@A[esi*8+2], ax
	shr	ecx, 16					; 00000010H
	shr	eax, 24					; 00000018H
	mov	BYTE PTR ?_gdt@@3PAUgdt_descriptor@@A[esi*8+4], cl
	mov	BYTE PTR ?_gdt@@3PAUgdt_descriptor@@A[esi*8+7], al
	mov	eax, DWORD PTR _limit$[esp+16]

; 24   : 	_gdt[i].grand = (uint8_t)((limit >> 16) & 0x0f);

	mov	ecx, eax
	mov	WORD PTR [edi], ax

; 25   : 	_gdt[i].grand |= grand & 0xf0;

	mov	al, BYTE PTR _grand$[esp+16]
	shr	ecx, 16					; 00000010H
	xor	cl, al
	add	esp, 12					; 0000000cH
	and	cl, 15					; 0000000fH
	xor	cl, al
	mov	BYTE PTR ?_gdt@@3PAUgdt_descriptor@@A[esi*8+5], dl
	mov	BYTE PTR ?_gdt@@3PAUgdt_descriptor@@A[esi*8+6], cl
	pop	edi
$LN2@gdt_set_de:
	pop	esi

; 26   : }

	ret	0
?gdt_set_descriptor@@YAXIIIEE@Z ENDP			; gdt_set_descriptor
_TEXT	ENDS
PUBLIC	?gdt_set_descriptor@@YAXIIIG@Z			; gdt_set_descriptor
; Function compile flags: /Ogtpy
;	COMDAT ?gdt_set_descriptor@@YAXIIIG@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
_base$ = 12						; size = 4
_limit$ = 16						; size = 4
_attr$ = 20						; size = 2
?gdt_set_descriptor@@YAXIIIG@Z PROC			; gdt_set_descriptor, COMDAT

; 30   : 	gdt_set_descriptor(i,base,limit,attr & 0xff,(attr >> 8) & 0xf0);

	mov	eax, DWORD PTR _attr$[esp-4]
	mov	edx, DWORD PTR _limit$[esp-4]
	movzx	ecx, ah
	and	ecx, -16				; fffffff0H
	push	ecx
	mov	ecx, DWORD PTR _i$[esp]
	push	eax
	mov	eax, DWORD PTR _base$[esp+4]
	push	edx
	push	eax
	push	ecx
	call	?gdt_set_descriptor@@YAXIIIEE@Z		; gdt_set_descriptor
	add	esp, 20					; 00000014H

; 31   : 	////DbgPrintf("idx: %d   base: 0x%x \n",i,base);
; 32   : 	//_gdt[i].baseLo	= (uint16_t)(base & 0xffff);
; 33   : 	//_gdt[i].baseMid	= (uint8_t)((base >>16) & 0xff);
; 34   : 	//_gdt[i].baseHi	= (uint8_t)((base >> 24) & 0xff);
; 35   : 	//_gdt[i].limit		= (uint16_t)(limit & 0xffff);
; 36   : 	//_gdt[i].flags		= (attr & 0xff);
; 37   : 	//_gdt[i].grand		= ((attr >> 8) & 0xf0) | (uint8_t)((limit >> 16) & 0x0f);
; 38   : }

	ret	0
?gdt_set_descriptor@@YAXIIIG@Z ENDP			; gdt_set_descriptor
_TEXT	ENDS
PUBLIC	?i86_gdt_get_descriptor@@YAPAUgdt_descriptor@@H@Z ; i86_gdt_get_descriptor
; Function compile flags: /Ogtpy
;	COMDAT ?i86_gdt_get_descriptor@@YAPAUgdt_descriptor@@H@Z
_TEXT	SEGMENT
_i$ = 8							; size = 4
?i86_gdt_get_descriptor@@YAPAUgdt_descriptor@@H@Z PROC	; i86_gdt_get_descriptor, COMDAT

; 42   : 	if (i > MAX_DESCRIPTORS)

	mov	eax, DWORD PTR _i$[esp-4]
	cmp	eax, 256				; 00000100H
	jle	SHORT $LN1@i86_gdt_ge

; 43   : 		return 0;

	xor	eax, eax

; 46   : }

	ret	0
$LN1@i86_gdt_ge:

; 44   : 
; 45   : 	return &_gdt[i];

	lea	eax, DWORD PTR ?_gdt@@3PAUgdt_descriptor@@A[eax*8]

; 46   : }

	ret	0
?i86_gdt_get_descriptor@@YAPAUgdt_descriptor@@H@Z ENDP	; i86_gdt_get_descriptor
; Function compile flags: /Ogtpy
_TEXT	ENDS
;	COMDAT ?gdt_install@@YAXXZ
_TEXT	SEGMENT
?gdt_install@@YAXXZ PROC				; gdt_install, COMDAT

; 50   : 	_asm lgdt [_gdtr]

	lgdt	FWORD PTR ?_gdtr@@3Ugdtr@@A		; _gdtr

; 51   : }

	ret	0
?gdt_install@@YAXXZ ENDP				; gdt_install
_TEXT	ENDS
PUBLIC	?i86_gdt_initialize@@YAHXZ			; i86_gdt_initialize
; Function compile flags: /Ogtpy
;	COMDAT ?i86_gdt_initialize@@YAHXZ
_TEXT	SEGMENT
?i86_gdt_initialize@@YAHXZ PROC				; i86_gdt_initialize, COMDAT

; 54   : {

	push	ebx

; 55   : 	_gdtr.m_limit = (sizeof(GDT_DESCRIPTOR) * MAX_DESCRIPTORS) - 1;
; 56   : 	_gdtr.m_base = (uint32_t) &_gdt[0];
; 57   : 
; 58   : 	gdt_set_descriptor(0,0,0,0,0);

	push	8
	xor	ebx, ebx
	push	ebx
	push	OFFSET ?_gdt@@3PAUgdt_descriptor@@A	; _gdt
	mov	WORD PTR ?_gdtr@@3Ugdtr@@A, 2047	; 000007ffH
	mov	DWORD PTR ?_gdtr@@3Ugdtr@@A+2, OFFSET ?_gdt@@3PAUgdt_descriptor@@A ; _gdt
	call	?memset@@YAPAXPAXDI@Z			; memset

; 59   : 
; 60   : 	/*gdt_set_descriptor(1,0,0xfffff,
; 61   : 		I86_GDT_DESC_READWRITE | I86_GDT_DESC_EXEC_CODE | I86_GDT_DESC_CODEDATA | I86_GDT_DESC_MEMORY ,
; 62   : 		I86_GDT_GRAND_4K | I86_GDT_GRAND_32BIT | I86_GDT_GRAND_LIMITHI_MASK);
; 63   : 
; 64   : 	gdt_set_descriptor(2,0,0xfffff,
; 65   : 		I86_GDT_DESC_READWRITE | I86_GDT_DESC_CODEDATA |I86_GDT_DESC_MEMORY ,
; 66   : 		I86_GDT_GRAND_4K | I86_GDT_GRAND_32BIT | I86_GDT_GRAND_LIMITHI_MASK);*/
; 67   : 
; 68   : 	gdt_set_descriptor(1,0,0xfffff,
; 69   : 		DA_32 | DA_CR | DA_LIMIT_4K );

	push	8
	push	ebx
	push	OFFSET ?_gdt@@3PAUgdt_descriptor@@A+8
	mov	WORD PTR ?_gdt@@3PAUgdt_descriptor@@A+2, bx
	mov	BYTE PTR ?_gdt@@3PAUgdt_descriptor@@A+4, bl
	mov	BYTE PTR ?_gdt@@3PAUgdt_descriptor@@A+7, bl
	mov	WORD PTR ?_gdt@@3PAUgdt_descriptor@@A, bx
	mov	BYTE PTR ?_gdt@@3PAUgdt_descriptor@@A+5, bl
	mov	BYTE PTR ?_gdt@@3PAUgdt_descriptor@@A+6, bl
	call	?memset@@YAPAXPAXDI@Z			; memset

; 70   : 	gdt_set_descriptor(2,0,0xfffff,
; 71   : 		DA_32 | DA_DRW | DA_LIMIT_4K );

	push	8
	push	ebx
	push	OFFSET ?_gdt@@3PAUgdt_descriptor@@A+16
	mov	WORD PTR ?_gdt@@3PAUgdt_descriptor@@A+10, bx
	mov	BYTE PTR ?_gdt@@3PAUgdt_descriptor@@A+12, bl
	mov	BYTE PTR ?_gdt@@3PAUgdt_descriptor@@A+15, bl
	mov	WORD PTR ?_gdt@@3PAUgdt_descriptor@@A+8, 65535 ; 0000ffffH
	mov	BYTE PTR ?_gdt@@3PAUgdt_descriptor@@A+13, 154 ; 0000009aH
	mov	BYTE PTR ?_gdt@@3PAUgdt_descriptor@@A+14, 207 ; 000000cfH
	call	?memset@@YAPAXPAXDI@Z			; memset
	add	esp, 36					; 00000024H
	mov	WORD PTR ?_gdt@@3PAUgdt_descriptor@@A+18, bx
	mov	BYTE PTR ?_gdt@@3PAUgdt_descriptor@@A+20, bl
	mov	BYTE PTR ?_gdt@@3PAUgdt_descriptor@@A+23, bl
	mov	WORD PTR ?_gdt@@3PAUgdt_descriptor@@A+16, 65535 ; 0000ffffH
	mov	BYTE PTR ?_gdt@@3PAUgdt_descriptor@@A+21, 146 ; 00000092H
	mov	BYTE PTR ?_gdt@@3PAUgdt_descriptor@@A+22, 207 ; 000000cfH

; 72   : 
; 73   : 	gdt_install();

	lgdt	FWORD PTR ?_gdtr@@3Ugdtr@@A		; _gdtr

; 74   : 
; 75   : 	return 0;

	xor	eax, eax
	pop	ebx

; 76   : }

	ret	0
?i86_gdt_initialize@@YAHXZ ENDP				; i86_gdt_initialize
_TEXT	ENDS
END
