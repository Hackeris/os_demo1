; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	i:\os\10\a\krnl\krnl\vmm.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?_cur_directory@@3PAUpdirectory@@A		; _cur_directory
PUBLIC	?_cur_pdbr@@3IA					; _cur_pdbr
_BSS	SEGMENT
?_cur_directory@@3PAUpdirectory@@A DD 01H DUP (?)	; _cur_directory
?_cur_pdbr@@3IA DD 01H DUP (?)				; _cur_pdbr
_BSS	ENDS
PUBLIC	?vmmngr_switch_pdirectory@@YA_NPAUpdirectory@@@Z ; vmmngr_switch_pdirectory
EXTRN	?pmmgr_load_PDBR@@YAXI@Z:PROC			; pmmgr_load_PDBR
; Function compile flags: /Ogtpy
; File i:\os\10\a\krnl\krnl\vmm.cpp
;	COMDAT ?vmmngr_switch_pdirectory@@YA_NPAUpdirectory@@@Z
_TEXT	SEGMENT
_dir$ = 8						; size = 4
?vmmngr_switch_pdirectory@@YA_NPAUpdirectory@@@Z PROC	; vmmngr_switch_pdirectory, COMDAT

; 56   : 	if (!dir)

	mov	eax, DWORD PTR _dir$[esp-4]
	test	eax, eax
	jne	SHORT $LN1@vmmngr_swi

; 57   : 		return false;

	xor	al, al

; 61   : }

	ret	0
$LN1@vmmngr_swi:

; 58   : 	_cur_directory = dir;

	mov	DWORD PTR ?_cur_directory@@3PAUpdirectory@@A, eax ; _cur_directory

; 59   : 	pmmgr_load_PDBR (_cur_pdbr);

	mov	eax, DWORD PTR ?_cur_pdbr@@3IA		; _cur_pdbr
	push	eax
	call	?pmmgr_load_PDBR@@YAXI@Z		; pmmgr_load_PDBR
	add	esp, 4

; 60   : 	return true;

	mov	al, 1

; 61   : }

	ret	0
?vmmngr_switch_pdirectory@@YA_NPAUpdirectory@@@Z ENDP	; vmmngr_switch_pdirectory
_TEXT	ENDS
PUBLIC	?vmmngr_flush_tlb_entry@@YAXI@Z			; vmmngr_flush_tlb_entry
; Function compile flags: /Ogtpy
;	COMDAT ?vmmngr_flush_tlb_entry@@YAXI@Z
_TEXT	SEGMENT
_addr$ = 8						; size = 4
?vmmngr_flush_tlb_entry@@YAXI@Z PROC			; vmmngr_flush_tlb_entry, COMDAT

; 65   : 	_asm {
; 66   : 		cli

	cli

; 67   : 		invlpg	addr

	invlpg	DWORD PTR _addr$[esp-4]

; 68   : 		sti

	sti

; 69   : 	}
; 70   : }

	ret	0
?vmmngr_flush_tlb_entry@@YAXI@Z ENDP			; vmmngr_flush_tlb_entry
_TEXT	ENDS
PUBLIC	?vmmngr_get_directory@@YAPAUpdirectory@@XZ	; vmmngr_get_directory
; Function compile flags: /Ogtpy
;	COMDAT ?vmmngr_get_directory@@YAPAUpdirectory@@XZ
_TEXT	SEGMENT
?vmmngr_get_directory@@YAPAUpdirectory@@XZ PROC		; vmmngr_get_directory, COMDAT

; 74   : 	return _cur_directory;

	mov	eax, DWORD PTR ?_cur_directory@@3PAUpdirectory@@A ; _cur_directory

; 75   : }

	ret	0
?vmmngr_get_directory@@YAPAUpdirectory@@XZ ENDP		; vmmngr_get_directory
_TEXT	ENDS
PUBLIC	?vmmngr_alloc_page@@YA_NPAI@Z			; vmmngr_alloc_page
EXTRN	?pt_entry_add_attrib@@YAXPAII@Z:PROC		; pt_entry_add_attrib
EXTRN	?pt_entry_set_frame@@YAXPAII@Z:PROC		; pt_entry_set_frame
EXTRN	?pmmgr_alloc_block@@YAPAXXZ:PROC		; pmmgr_alloc_block
; Function compile flags: /Ogtpy
;	COMDAT ?vmmngr_alloc_page@@YA_NPAI@Z
_TEXT	SEGMENT
_e$ = 8							; size = 4
?vmmngr_alloc_page@@YA_NPAI@Z PROC			; vmmngr_alloc_page, COMDAT

; 79   : 	// allocate a free physical frame
; 80   : 	void* p = pmmgr_alloc_block ();

	call	?pmmgr_alloc_block@@YAPAXXZ		; pmmgr_alloc_block

; 81   : 	if (!p)

	test	eax, eax
	jne	SHORT $LN1@vmmngr_all

; 82   : 		return false;

	xor	al, al

; 89   : }

	ret	0
$LN1@vmmngr_all:
	push	esi

; 83   : 
; 84   : 	// map it to the page
; 85   : 	pt_entry_set_frame (e, (physical_addr)p);

	mov	esi, DWORD PTR _e$[esp]
	push	eax
	push	esi
	call	?pt_entry_set_frame@@YAXPAII@Z		; pt_entry_set_frame

; 86   : 	pt_entry_add_attrib (e, I86_PTE_PRESENT);

	push	1
	push	esi
	call	?pt_entry_add_attrib@@YAXPAII@Z		; pt_entry_add_attrib
	add	esp, 16					; 00000010H

; 87   : 
; 88   : 	return true;

	mov	al, 1
	pop	esi

; 89   : }

	ret	0
?vmmngr_alloc_page@@YA_NPAI@Z ENDP			; vmmngr_alloc_page
_TEXT	ENDS
PUBLIC	?vmmngr_free_page@@YAXPAI@Z			; vmmngr_free_page
EXTRN	?pt_entry_del_attrib@@YAXPAII@Z:PROC		; pt_entry_del_attrib
EXTRN	?pmmgr_free_block@@YAXPAX@Z:PROC		; pmmgr_free_block
EXTRN	?pt_entry_pfn@@YAII@Z:PROC			; pt_entry_pfn
; Function compile flags: /Ogtpy
;	COMDAT ?vmmngr_free_page@@YAXPAI@Z
_TEXT	SEGMENT
_e$ = 8							; size = 4
?vmmngr_free_page@@YAXPAI@Z PROC			; vmmngr_free_page, COMDAT

; 92   : {

	push	esi

; 93   : 	void* p = (void*)pt_entry_pfn (*e);

	mov	esi, DWORD PTR _e$[esp]
	mov	eax, DWORD PTR [esi]
	push	eax
	call	?pt_entry_pfn@@YAII@Z			; pt_entry_pfn
	add	esp, 4

; 94   : 	if (p)

	test	eax, eax
	je	SHORT $LN1@vmmngr_fre

; 95   : 		pmmgr_free_block (p);

	push	eax
	call	?pmmgr_free_block@@YAXPAX@Z		; pmmgr_free_block
	add	esp, 4
$LN1@vmmngr_fre:

; 96   : 
; 97   : 	pt_entry_del_attrib (e, I86_PTE_PRESENT);

	push	1
	push	esi
	call	?pt_entry_del_attrib@@YAXPAII@Z		; pt_entry_del_attrib
	add	esp, 8
	pop	esi

; 98   : }

	ret	0
?vmmngr_free_page@@YAXPAI@Z ENDP			; vmmngr_free_page
_TEXT	ENDS
PUBLIC	?vmmngr_initialize@@YAXXZ			; vmmngr_initialize
EXTRN	?pmmgr_paging_enable@@YAX_N@Z:PROC		; pmmgr_paging_enable
EXTRN	?pmmgr_alloc_blocks@@YAPAXI@Z:PROC		; pmmgr_alloc_blocks
EXTRN	?pmmgr_get_memory_size@@YAIXZ:PROC		; pmmgr_get_memory_size
; Function compile flags: /Ogtpy
;	COMDAT ?vmmngr_initialize@@YAXXZ
_TEXT	SEGMENT
?vmmngr_initialize@@YAXXZ PROC				; vmmngr_initialize, COMDAT

; 106  : {

	push	ebx
	push	edi

; 107  : 	uint32_t* page_dir_base = (uint32_t*)pmmgr_alloc_block();

	call	?pmmgr_alloc_block@@YAPAXXZ		; pmmgr_alloc_block
	mov	ebx, eax

; 108  : 	uint32_t* page_tbl_base;
; 109  : 
; 110  : 	uint32_t	mem_size = pmmgr_get_memory_size();

	call	?pmmgr_get_memory_size@@YAIXZ		; pmmgr_get_memory_size

; 111  : 	//mem_size = 5 * 1024;
; 112  : 
; 113  : 	uint32_t tbl_count = mem_size / 4096;	//	4MB every page table can refer

	mov	edi, eax
	shr	edi, 12					; 0000000cH

; 114  : 	uint32_t i = 0,count;
; 115  : 	if(mem_size % 4096 != 0){

	test	eax, 4095				; 00000fffH
	je	SHORT $LN5@vmmngr_ini

; 116  : 		tbl_count ++;

	add	edi, 1
$LN5@vmmngr_ini:
	push	esi

; 117  : 	}
; 118  : 	page_tbl_base = (uint32_t*)pmmgr_alloc_blocks(tbl_count);

	push	edi
	call	?pmmgr_alloc_blocks@@YAPAXI@Z		; pmmgr_alloc_blocks
	add	esp, 4

; 119  : 	//	initialize page directories
; 120  : 	count = tbl_count;
; 121  : 	while(count --){

	test	edi, edi
	mov	ecx, edi
	je	SHORT $LN13@vmmngr_ini
	mov	esi, ebx
	mov	edx, eax
	push	ebp
$LL4@vmmngr_ini:

; 122  : 		((uint32_t*)page_dir_base)[i] = (uint32_t)(page_tbl_base + i * 4096);
; 123  : 		((uint32_t*)page_dir_base)[i] |= I86_PDE_PRESENT | I86_PDE_USER |I86_PDE_WRITABLE | I86_PDE_USER;

	mov	ebp, edx
	or	ebp, 7
	sub	ecx, 1
	mov	DWORD PTR [esi], ebp

; 124  : 		i++;

	add	edx, 16384				; 00004000H
	add	esi, 4
	test	ecx, ecx
	jne	SHORT $LL4@vmmngr_ini
	pop	ebp
$LN13@vmmngr_ini:

; 125  : 	}
; 126  : 	//	initialize page tables
; 127  : 	count = tbl_count * 1024;

	shl	edi, 10					; 0000000aH
	mov	edx, edi

; 128  : 	i = 0;
; 129  : 	while(count --){

	je	SHORT $LN18@vmmngr_ini

; 125  : 	}
; 126  : 	//	initialize page tables
; 127  : 	count = tbl_count * 1024;

	xor	ecx, ecx
$LL2@vmmngr_ini:

; 130  : 		((uint32_t*)page_tbl_base)[i] = (i * 4096) | 
; 131  : 			I86_PTE_PRESENT | I86_PTE_USER |I86_PTE_WRITABLE | I86_PDE_USER;

	mov	esi, ecx
	or	esi, 7
	sub	edx, 1
	mov	DWORD PTR [eax], esi

; 132  : 		i++;

	add	ecx, 4096				; 00001000H
	add	eax, 4
	test	edx, edx
	jne	SHORT $LL2@vmmngr_ini
$LN18@vmmngr_ini:

; 133  : 	}
; 134  : 	// store current PDBR
; 135  : 	_cur_pdbr = (physical_addr)page_dir_base;
; 136  : 
; 137  : 	// switch to our page directory
; 138  : 	vmmngr_switch_pdirectory ((pdirectory*)_cur_pdbr);

	test	ebx, ebx
	mov	DWORD PTR ?_cur_pdbr@@3IA, ebx		; _cur_pdbr
	pop	esi
	je	SHORT $LN9@vmmngr_ini
	push	ebx
	mov	DWORD PTR ?_cur_directory@@3PAUpdirectory@@A, ebx ; _cur_directory
	call	?pmmgr_load_PDBR@@YAXI@Z		; pmmgr_load_PDBR
	add	esp, 4
$LN9@vmmngr_ini:

; 139  : 
; 140  : 	// enable paging
; 141  : 	pmmgr_paging_enable (true);

	push	1
	call	?pmmgr_paging_enable@@YAX_N@Z		; pmmgr_paging_enable
	add	esp, 4
	pop	edi
	pop	ebx

; 142  : }

	ret	0
?vmmngr_initialize@@YAXXZ ENDP				; vmmngr_initialize
_TEXT	ENDS
PUBLIC	?ldt_seg_linear@@YAIPAU_tagPROC@@H@Z		; ldt_seg_linear
; Function compile flags: /Ogtpy
;	COMDAT ?ldt_seg_linear@@YAIPAU_tagPROC@@H@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
_idx$ = 12						; size = 4
?ldt_seg_linear@@YAIPAU_tagPROC@@H@Z PROC		; ldt_seg_linear, COMDAT

; 146  : 	LDT_DESCRIPTOR* d = &p->ldts[idx];

	mov	eax, DWORD PTR _p$[esp-4]
	mov	ecx, DWORD PTR _idx$[esp-4]

; 147  : 	return (d->baseHi << 24) | (d->baseMid << 16) | (d->baseLo);

	xor	edx, edx
	mov	dh, BYTE PTR [eax+ecx*8+81]
	mov	dl, BYTE PTR [eax+ecx*8+78]
	movzx	eax, WORD PTR [eax+ecx*8+76]
	shl	edx, 16					; 00000010H
	or	eax, edx

; 148  : }

	ret	0
?ldt_seg_linear@@YAIPAU_tagPROC@@H@Z ENDP		; ldt_seg_linear
_TEXT	ENDS
PUBLIC	?va2la@@YAPAXHPAX@Z				; va2la
EXTRN	?proc_table@@3PAU_tagPROC@@A:BYTE		; proc_table
; Function compile flags: /Ogtpy
;	COMDAT ?va2la@@YAPAXHPAX@Z
_TEXT	SEGMENT
_pid$ = 8						; size = 4
_va$ = 12						; size = 4
?va2la@@YAPAXHPAX@Z PROC				; va2la, COMDAT

; 152  : 	PROCESS* p = &proc_table[pid];

	mov	eax, DWORD PTR _pid$[esp-4]
	imul	eax, 194				; 000000c2H

; 153  : 
; 154  : 	uint32_t seg_base = ldt_seg_linear(p,INDEX_LDT_RW);
; 155  : 	uint32_t la = seg_base + (uint32_t)va;
; 156  : 
; 157  : 	if(pid < NR_TASKS + NR_NATIVE_PROCS){
; 158  : 		//	assert(la == (uint32_t)val);
; 159  : 	}
; 160  : 
; 161  : 	return (void*)la;

	xor	ecx, ecx
	add	eax, OFFSET ?proc_table@@3PAU_tagPROC@@A+82
	mov	ch, BYTE PTR [eax+7]
	movzx	edx, WORD PTR [eax+2]
	mov	cl, BYTE PTR [eax+4]
	shl	ecx, 16					; 00000010H
	or	ecx, edx
	add	ecx, DWORD PTR _va$[esp-4]
	mov	eax, ecx

; 162  : }

	ret	0
?va2la@@YAPAXHPAX@Z ENDP				; va2la
_TEXT	ENDS
END
