; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	i:\os\10\a\krnl\krnl\flpy.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

_BSS	SEGMENT
__current_drive DB 01H DUP (?)
_BSS	ENDS
PUBLIC	?dma_initialize_floppy@@YA_NPAEI@Z		; dma_initialize_floppy
EXTRN	?dma_unmask_all@@YAXH@Z:PROC			; dma_unmask_all
EXTRN	?dma_set_read@@YAXE@Z:PROC			; dma_set_read
EXTRN	?dma_set_count@@YAXEEE@Z:PROC			; dma_set_count
EXTRN	?dma_set_address@@YAXEEE@Z:PROC			; dma_set_address
EXTRN	?dma_reset_flipflop@@YAXH@Z:PROC		; dma_reset_flipflop
EXTRN	?dma_mask_channel@@YAXE@Z:PROC			; dma_mask_channel
EXTRN	?dma_reset@@YAXH@Z:PROC				; dma_reset
; Function compile flags: /Ogtpy
; File i:\os\10\a\krnl\krnl\flpy.cpp
;	COMDAT ?dma_initialize_floppy@@YA_NPAEI@Z
_TEXT	SEGMENT
_c$ = -8						; size = 4
_buffer$ = 8						; size = 4
_length$ = 12						; size = 4
?dma_initialize_floppy@@YA_NPAEI@Z PROC			; dma_initialize_floppy, COMDAT

; 61   : {

	sub	esp, 8
	push	esi

; 62   :    union{
; 63   :       uint8_t byte[4];//Lo[0], Mid[1], Hi[2]
; 64   :       unsigned long l;
; 65   :    }a, c;
; 66   : 
; 67   :    a.l=(unsigned)buffer;
; 68   :    c.l=(unsigned)length-1;

	mov	esi, DWORD PTR _length$[esp+8]
	push	edi

; 69   : 
; 70   :    //Check for buffer issues
; 71   :    if ((a.l >> 24) || (c.l >> 16) || (((a.l & 0xffff)+c.l) >> 16)){

	mov	edi, DWORD PTR _buffer$[esp+12]
	add	esi, -1
	test	edi, -16777216				; ff000000H
	mov	DWORD PTR _c$[esp+16], esi
	jne	SHORT $LN1@dma_initia
	test	esi, -65536				; ffff0000H
	jne	SHORT $LN1@dma_initia
	movzx	eax, di
	add	eax, esi
	test	eax, -65536				; ffff0000H
	jne	SHORT $LN1@dma_initia

; 80   :    }
; 81   : 
; 82   :    dma_reset (1);

	push	1
	call	?dma_reset@@YAXH@Z			; dma_reset

; 83   :    dma_mask_channel( FDC_DMA_CHANNEL );//Mask channel 2

	push	2
	call	?dma_mask_channel@@YAXE@Z		; dma_mask_channel

; 84   :    dma_reset_flipflop ( 1 );//Flipflop reset on DMA 1

	push	1
	call	?dma_reset_flipflop@@YAXH@Z		; dma_reset_flipflop

; 85   : 
; 86   :    dma_set_address( FDC_DMA_CHANNEL, a.byte[0],a.byte[1]);//Buffer address

	mov	ecx, DWORD PTR _buffer$[esp+25]
	push	ecx
	push	edi
	push	2
	call	?dma_set_address@@YAXEEE@Z		; dma_set_address

; 87   :    dma_reset_flipflop( 1 );//Flipflop reset on DMA 1

	push	1
	call	?dma_reset_flipflop@@YAXH@Z		; dma_reset_flipflop

; 88   : 
; 89   :    dma_set_count( FDC_DMA_CHANNEL, c.byte[0],c.byte[1]);//Set count

	mov	edx, DWORD PTR _c$[esp+45]
	push	edx
	push	esi
	push	2
	call	?dma_set_count@@YAXEEE@Z		; dma_set_count

; 90   :    dma_set_read ( FDC_DMA_CHANNEL );

	push	2
	call	?dma_set_read@@YAXE@Z			; dma_set_read

; 91   : 
; 92   :    dma_unmask_all( 1 );//Unmask channel 2

	push	1
	call	?dma_unmask_all@@YAXH@Z			; dma_unmask_all
	add	esp, 48					; 00000030H
	pop	edi

; 93   : 
; 94   :    return true;

	mov	al, 1
	pop	esi

; 95   : }

	add	esp, 8
	ret	0
$LN1@dma_initia:
	pop	edi

; 72   : #ifdef _DEBUG
; 73   :       _asm{
; 74   :          mov      eax, 0x1337
; 75   :          cli
; 76   :          hlt
; 77   :       }
; 78   : #endif
; 79   :       return false;

	xor	al, al
	pop	esi

; 95   : }

	add	esp, 8
	ret	0
?dma_initialize_floppy@@YA_NPAEI@Z ENDP			; dma_initialize_floppy
_TEXT	ENDS
PUBLIC	?flpydsk_read_status@@YAEXZ			; flpydsk_read_status
EXTRN	?in_byte@@YAEG@Z:PROC				; in_byte
; Function compile flags: /Ogtpy
;	COMDAT ?flpydsk_read_status@@YAEXZ
_TEXT	SEGMENT
?flpydsk_read_status@@YAEXZ PROC			; flpydsk_read_status, COMDAT

; 101  : 	// just return main status register
; 102  : 	return inportb (FLPYDSK_MSR);

	push	1012					; 000003f4H
	call	?in_byte@@YAEG@Z			; in_byte
	add	esp, 4

; 103  : }

	ret	0
?flpydsk_read_status@@YAEXZ ENDP			; flpydsk_read_status
_TEXT	ENDS
PUBLIC	?flpydsk_write_dor@@YAXE@Z			; flpydsk_write_dor
EXTRN	?out_byte@@YAXGE@Z:PROC				; out_byte
; Function compile flags: /Ogtpy
;	COMDAT ?flpydsk_write_dor@@YAXE@Z
_TEXT	SEGMENT
_val$ = 8						; size = 1
?flpydsk_write_dor@@YAXE@Z PROC				; flpydsk_write_dor, COMDAT

; 108  : 	// write the digital output register
; 109  : 	outportb (FLPYDSK_DOR, val);

	mov	eax, DWORD PTR _val$[esp-4]
	push	eax
	push	1010					; 000003f2H
	call	?out_byte@@YAXGE@Z			; out_byte
	add	esp, 8

; 110  : }

	ret	0
?flpydsk_write_dor@@YAXE@Z ENDP				; flpydsk_write_dor
_TEXT	ENDS
PUBLIC	?flpydsk_send_command@@YAXE@Z			; flpydsk_send_command
; Function compile flags: /Ogtpy
;	COMDAT ?flpydsk_send_command@@YAXE@Z
_TEXT	SEGMENT
_cmd$ = 8						; size = 1
?flpydsk_send_command@@YAXE@Z PROC			; flpydsk_send_command, COMDAT

; 114  : {

	push	esi

; 115  : 	// wait until data register is ready. We send commands to the data register
; 116  : 	for (int i = 0; i < 500; i++ )

	xor	esi, esi
$LL4@flpydsk_se:

; 117  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	push	1012					; 000003f4H
	call	?in_byte@@YAEG@Z			; in_byte
	add	esp, 4
	test	al, al
	js	SHORT $LN10@flpydsk_se
	add	esi, 1
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL4@flpydsk_se
	pop	esi

; 119  : }

	ret	0
$LN10@flpydsk_se:

; 118  : 			return outportb (FLPYDSK_FIFO, cmd);

	mov	eax, DWORD PTR _cmd$[esp]
	push	eax
	push	1013					; 000003f5H
	call	?out_byte@@YAXGE@Z			; out_byte
	add	esp, 8
	pop	esi

; 119  : }

	ret	0
?flpydsk_send_command@@YAXE@Z ENDP			; flpydsk_send_command
_TEXT	ENDS
PUBLIC	?flpydsk_read_data@@YAEXZ			; flpydsk_read_data
; Function compile flags: /Ogtpy
;	COMDAT ?flpydsk_read_data@@YAEXZ
_TEXT	SEGMENT
?flpydsk_read_data@@YAEXZ PROC				; flpydsk_read_data, COMDAT

; 123  : {

	push	esi

; 124  : 	// same as above function but returns data register for reading
; 125  : 	for (int i = 0; i < 500; i++ )

	xor	esi, esi
$LL4@flpydsk_re:

; 126  : 		if ( flpydsk_read_status () & FLPYDSK_MSR_MASK_DATAREG )

	push	1012					; 000003f4H
	call	?in_byte@@YAEG@Z			; in_byte
	add	esp, 4
	test	al, al
	js	SHORT $LN10@flpydsk_re
	add	esi, 1
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL4@flpydsk_re

; 128  : 	return 0;

	xor	al, al
	pop	esi

; 129  : }

	ret	0
$LN10@flpydsk_re:

; 127  : 			return inportb (FLPYDSK_FIFO);

	push	1013					; 000003f5H
	call	?in_byte@@YAEG@Z			; in_byte
	add	esp, 4
	pop	esi

; 129  : }

	ret	0
?flpydsk_read_data@@YAEXZ ENDP				; flpydsk_read_data
_TEXT	ENDS
PUBLIC	?flpydsk_write_ccr@@YAXE@Z			; flpydsk_write_ccr
; Function compile flags: /Ogtpy
;	COMDAT ?flpydsk_write_ccr@@YAXE@Z
_TEXT	SEGMENT
_val$ = 8						; size = 1
?flpydsk_write_ccr@@YAXE@Z PROC				; flpydsk_write_ccr, COMDAT

; 134  : 	outportb (FLPYDSK_CTRL, val);

	mov	eax, DWORD PTR _val$[esp-4]
	push	eax
	push	1015					; 000003f7H
	call	?out_byte@@YAXGE@Z			; out_byte
	add	esp, 8

; 135  : }

	ret	0
?flpydsk_write_ccr@@YAXE@Z ENDP				; flpydsk_write_ccr
_TEXT	ENDS
PUBLIC	?flpydsk_wait_irq@@YAXXZ			; flpydsk_wait_irq
EXTRN	?send_recv@@YAHHHPAU_tagMESSAGE@@@Z:PROC	; send_recv
; Function compile flags: /Ogtpy
;	COMDAT ?flpydsk_wait_irq@@YAXXZ
_TEXT	SEGMENT
_msg$ = -48						; size = 48
?flpydsk_wait_irq@@YAXXZ PROC				; flpydsk_wait_irq, COMDAT

; 138  : {

	sub	esp, 48					; 00000030H

; 139  : 	MESSAGE	msg;
; 140  : 	send_recv(RECEIVE,INTERRUPT,&msg);

	lea	eax, DWORD PTR _msg$[esp+48]
	push	eax
	push	-10					; fffffff6H
	push	2
	call	?send_recv@@YAHHHPAU_tagMESSAGE@@@Z	; send_recv

; 141  : }

	add	esp, 60					; 0000003cH
	ret	0
?flpydsk_wait_irq@@YAXXZ ENDP				; flpydsk_wait_irq
_TEXT	ENDS
PUBLIC	?i86_flpy_irq@@YAXXZ				; i86_flpy_irq
EXTRN	?inform_int@@YAXH@Z:PROC			; inform_int
EXTRN	?_save@@YAXXZ:PROC				; _save
; Function compile flags: /Ogtpy
;	COMDAT ?i86_flpy_irq@@YAXXZ
_TEXT	SEGMENT
?i86_flpy_irq@@YAXXZ PROC				; i86_flpy_irq, COMDAT

; 147  : 		save();

	sub	esp, 4
	pushad
	call	?_save@@YAXXZ				; _save

; 148  : 	_asm{
; 149  : 		in	al,INT_M_CTLMASK

	in	al, 33					; 00000021H

; 150  : 		or	al,( 1 << FLOPPY_IRQ )

	or	al, 64					; 00000040H

; 151  : 		out	INT_M_CTLMASK,al

	out	33, al					; 00000021H

; 152  : 
; 153  : 		mov al,EOI

	mov	al, 32					; 00000020H

; 154  : 		out INT_M_CTL,al

	out	32, al					; 00000020H

; 155  : 	}
; 156  : 	_asm sti

	sti

; 157  : 	inform_int(TASK_FLPY);

	push	2
	call	?inform_int@@YAXH@Z			; inform_int
	add	esp, 4

; 158  : 	_asm cli

	cli

; 159  : 	_asm{
; 160  : 		in	al,INT_M_CTLMASK

	in	al, 33					; 00000021H

; 161  : 		and	al,~(1 << FLOPPY_IRQ)

	and	al, -65					; ffffffbfH

; 162  : 		out	INT_M_CTLMASK,al

	out	33, al					; 00000021H

; 163  : 	}
; 164  : 	_asm ret

	ret	0

; 165  : }

	ret	0
?i86_flpy_irq@@YAXXZ ENDP				; i86_flpy_irq
_TEXT	ENDS
PUBLIC	?flpydsk_check_int@@YAXPAI0@Z			; flpydsk_check_int
; Function compile flags: /Ogtpy
;	COMDAT ?flpydsk_check_int@@YAXPAI0@Z
_TEXT	SEGMENT
_st0$ = 8						; size = 4
_cyl$ = 12						; size = 4
?flpydsk_check_int@@YAXPAI0@Z PROC			; flpydsk_check_int, COMDAT

; 169  : 	flpydsk_send_command (FDC_CMD_CHECK_INT);

	push	8
	call	?flpydsk_send_command@@YAXE@Z		; flpydsk_send_command
	add	esp, 4

; 170  : 
; 171  : 	*st0 = flpydsk_read_data ();

	call	?flpydsk_read_data@@YAEXZ		; flpydsk_read_data
	mov	ecx, DWORD PTR _st0$[esp-4]
	movzx	eax, al
	mov	DWORD PTR [ecx], eax

; 172  : 	*cyl = flpydsk_read_data ();

	call	?flpydsk_read_data@@YAEXZ		; flpydsk_read_data
	movzx	edx, al
	mov	eax, DWORD PTR _cyl$[esp-4]
	mov	DWORD PTR [eax], edx

; 173  : }

	ret	0
?flpydsk_check_int@@YAXPAI0@Z ENDP			; flpydsk_check_int
_TEXT	ENDS
PUBLIC	?flpydsk_control_motor@@YAX_N@Z			; flpydsk_control_motor
EXTRN	?delay@@YAXI@Z:PROC				; delay
; Function compile flags: /Ogtpy
;	COMDAT ?flpydsk_control_motor@@YAX_N@Z
_TEXT	SEGMENT
_b$ = 8							; size = 1
?flpydsk_control_motor@@YAX_N@Z PROC			; flpydsk_control_motor, COMDAT

; 178  : 	// sanity check: invalid drive
; 179  : 	if (_current_drive > 3)

	mov	al, BYTE PTR __current_drive
	cmp	al, 3
	ja	SHORT $LN10@flpydsk_co

; 180  : 		return;
; 181  : 
; 182  : 	uint8_t motor = 0;
; 183  : 
; 184  : 	// select the correct mask based on current drive
; 185  : 	switch (_current_drive) {

	movzx	ecx, al
	xor	dl, dl
	cmp	ecx, 3
	ja	SHORT $LN7@flpydsk_co
	jmp	DWORD PTR $LN18@flpydsk_co[ecx*4]
$LN6@flpydsk_co:

; 186  : 
; 187  : 		case 0:
; 188  : 			motor = FLPYDSK_DOR_MASK_DRIVE0_MOTOR;

	mov	dl, 16					; 00000010H

; 189  : 			break;

	jmp	SHORT $LN7@flpydsk_co
$LN5@flpydsk_co:

; 190  : 		case 1:
; 191  : 			motor = FLPYDSK_DOR_MASK_DRIVE1_MOTOR;

	mov	dl, 32					; 00000020H

; 192  : 			break;

	jmp	SHORT $LN7@flpydsk_co
$LN4@flpydsk_co:

; 193  : 		case 2:
; 194  : 			motor = FLPYDSK_DOR_MASK_DRIVE2_MOTOR;

	mov	dl, 64					; 00000040H

; 195  : 			break;

	jmp	SHORT $LN7@flpydsk_co
$LN3@flpydsk_co:

; 196  : 		case 3:
; 197  : 			motor = FLPYDSK_DOR_MASK_DRIVE3_MOTOR;

	mov	dl, 128					; 00000080H
$LN7@flpydsk_co:

; 198  : 			break;
; 199  : 	}
; 200  : 
; 201  : 	// turn on or off the motor of that drive
; 202  : 	if (b)

	cmp	BYTE PTR _b$[esp-4], 0
	je	SHORT $LN2@flpydsk_co
	or	al, dl

; 203  : 		flpydsk_write_dor (uint8_t(_current_drive | motor | FLPYDSK_DOR_MASK_RESET | FLPYDSK_DOR_MASK_DMA));

	or	eax, 12					; 0000000cH
	push	eax

; 204  : 	else

	jmp	SHORT $LN17@flpydsk_co
$LN2@flpydsk_co:

; 205  : 		flpydsk_write_dor (FLPYDSK_DOR_MASK_RESET);

	push	4
$LN17@flpydsk_co:
	push	1010					; 000003f2H
	call	?out_byte@@YAXGE@Z			; out_byte
	add	esp, 8

; 206  : 
; 207  : 	//sleep (20);
; 208  : 	//milli_delay(20);
; 209  : 	delay(20);

	mov	DWORD PTR _b$[esp-4], 20		; 00000014H
	jmp	?delay@@YAXI@Z				; delay
$LN10@flpydsk_co:

; 210  : }

	ret	0
$LN18@flpydsk_co:
	DD	$LN6@flpydsk_co
	DD	$LN5@flpydsk_co
	DD	$LN4@flpydsk_co
	DD	$LN3@flpydsk_co
?flpydsk_control_motor@@YAX_N@Z ENDP			; flpydsk_control_motor
_TEXT	ENDS
PUBLIC	?flpydsk_drive_data@@YAXEEE_N@Z			; flpydsk_drive_data
; Function compile flags: /Ogtpy
;	COMDAT ?flpydsk_drive_data@@YAXEEE_N@Z
_TEXT	SEGMENT
_stepr$ = 8						; size = 1
_loadt$ = 12						; size = 1
_unloadt$ = 16						; size = 1
_dma$ = 20						; size = 1
?flpydsk_drive_data@@YAXEEE_N@Z PROC			; flpydsk_drive_data, COMDAT

; 215  : 	uint8_t data = 0;
; 216  : 
; 217  : 	// send command
; 218  : 	flpydsk_send_command (FDC_CMD_SPECIFY);

	push	3
	call	?flpydsk_send_command@@YAXE@Z		; flpydsk_send_command

; 219  : 	data = ( (stepr & 0xf) << 4) | (unloadt & 0xf);

	movzx	eax, BYTE PTR _stepr$[esp]
	mov	cl, BYTE PTR _unloadt$[esp]
	shl	al, 4
	and	cl, 15					; 0000000fH
	or	al, cl

; 220  : 		flpydsk_send_command (data);

	push	eax
	call	?flpydsk_send_command@@YAXE@Z		; flpydsk_send_command

; 221  : 	data = (( loadt << 1 ) | ( (dma) ? 0 : 1 ) );

	cmp	BYTE PTR _dma$[esp+4], 0
	mov	al, BYTE PTR _loadt$[esp+4]
	sete	dl
	add	al, al
	or	dl, al

; 222  : 		flpydsk_send_command (data);

	push	edx
	call	?flpydsk_send_command@@YAXE@Z		; flpydsk_send_command
	add	esp, 12					; 0000000cH

; 223  : }

	ret	0
?flpydsk_drive_data@@YAXEEE_N@Z ENDP			; flpydsk_drive_data
_TEXT	ENDS
PUBLIC	?flpydsk_calibrate@@YAHE@Z			; flpydsk_calibrate
; Function compile flags: /Ogtpy
;	COMDAT ?flpydsk_calibrate@@YAHE@Z
_TEXT	SEGMENT
_msg$3459 = -48						; size = 48
_drive$ = 8						; size = 1
?flpydsk_calibrate@@YAHE@Z PROC				; flpydsk_calibrate, COMDAT

; 227  : {

	sub	esp, 48					; 00000030H
	push	ebx

; 228  : 	uint32_t st0, cyl;
; 229  : 
; 230  : 	if (drive >= 4)

	mov	ebx, DWORD PTR _drive$[esp+48]
	cmp	bl, 4
	jb	SHORT $LN5@flpydsk_ca

; 231  : 		return -2;

	mov	eax, -2					; fffffffeH
	pop	ebx

; 254  : }

	add	esp, 48					; 00000030H
	ret	0
$LN5@flpydsk_ca:

; 232  : 
; 233  : 	// turn on the motor
; 234  : 	flpydsk_control_motor (true);

	mov	al, BYTE PTR __current_drive
	cmp	al, 3
	ja	SHORT $LN17@flpydsk_ca
	movzx	edx, al
	xor	cl, cl
	cmp	edx, 3
	ja	SHORT $LN14@flpydsk_ca
	jmp	DWORD PTR $LN119@flpydsk_ca[edx*4]
$LN13@flpydsk_ca:
	mov	cl, 16					; 00000010H
	jmp	SHORT $LN14@flpydsk_ca
$LN12@flpydsk_ca:
	mov	cl, 32					; 00000020H
	jmp	SHORT $LN14@flpydsk_ca
$LN11@flpydsk_ca:
	mov	cl, 64					; 00000040H
	jmp	SHORT $LN14@flpydsk_ca
$LN10@flpydsk_ca:
	mov	cl, 128					; 00000080H
$LN14@flpydsk_ca:
	or	al, cl
	or	eax, 12					; 0000000cH
	push	eax
	push	1010					; 000003f2H
	call	?out_byte@@YAXGE@Z			; out_byte
	push	20					; 00000014H
	call	?delay@@YAXI@Z				; delay
	add	esp, 12					; 0000000cH
$LN17@flpydsk_ca:
	push	edi

; 235  : 
; 236  : 	for (int i = 0; i < 10; i++) {

	xor	edi, edi
	push	esi
	npad	3
$LL4@flpydsk_ca:

; 237  : 
; 238  : 		// send command
; 239  : 		flpydsk_send_command ( FDC_CMD_CALIBRATE );

	xor	esi, esi
$LL26@flpydsk_ca:
	push	1012					; 000003f4H
	call	?in_byte@@YAEG@Z			; in_byte
	add	esp, 4
	test	al, al
	js	SHORT $LN103@flpydsk_ca
	add	esi, 1
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL26@flpydsk_ca

; 243  : 
; 244  : 		// did we fine cylinder 0? if so, we are done
; 245  : 		if (!cyl) {

	jmp	SHORT $LN24@flpydsk_ca
$LN103@flpydsk_ca:

; 237  : 
; 238  : 		// send command
; 239  : 		flpydsk_send_command ( FDC_CMD_CALIBRATE );

	push	7
	push	1013					; 000003f5H
	call	?out_byte@@YAXGE@Z			; out_byte
	add	esp, 8
$LN24@flpydsk_ca:

; 240  : 		flpydsk_send_command ( drive );

	xor	esi, esi
$LL34@flpydsk_ca:
	push	1012					; 000003f4H
	call	?in_byte@@YAEG@Z			; in_byte
	add	esp, 4
	test	al, al
	js	SHORT $LN104@flpydsk_ca
	add	esi, 1
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL34@flpydsk_ca

; 243  : 
; 244  : 		// did we fine cylinder 0? if so, we are done
; 245  : 		if (!cyl) {

	jmp	SHORT $LN32@flpydsk_ca
$LN104@flpydsk_ca:

; 240  : 		flpydsk_send_command ( drive );

	push	ebx
	push	1013					; 000003f5H
	call	?out_byte@@YAXGE@Z			; out_byte
	add	esp, 8
$LN32@flpydsk_ca:

; 241  : 		flpydsk_wait_irq ();

	lea	eax, DWORD PTR _msg$3459[esp+60]
	push	eax
	push	-10					; fffffff6H
	push	2
	call	?send_recv@@YAHHHPAU_tagMESSAGE@@@Z	; send_recv
	add	esp, 12					; 0000000cH

; 242  : 		flpydsk_check_int ( &st0, &cyl);

	xor	esi, esi
$LL46@flpydsk_ca:
	push	1012					; 000003f4H
	call	?in_byte@@YAEG@Z			; in_byte
	add	esp, 4
	test	al, al
	js	SHORT $LN105@flpydsk_ca
	add	esi, 1
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL46@flpydsk_ca

; 243  : 
; 244  : 		// did we fine cylinder 0? if so, we are done
; 245  : 		if (!cyl) {

	jmp	SHORT $LN44@flpydsk_ca
$LN105@flpydsk_ca:

; 242  : 		flpydsk_check_int ( &st0, &cyl);

	push	8
	push	1013					; 000003f5H
	call	?out_byte@@YAXGE@Z			; out_byte
	add	esp, 8
$LN44@flpydsk_ca:
	xor	esi, esi
	npad	1
$LL54@flpydsk_ca:
	push	1012					; 000003f4H
	call	?in_byte@@YAEG@Z			; in_byte
	add	esp, 4
	test	al, al
	js	SHORT $LN106@flpydsk_ca
	add	esi, 1
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL54@flpydsk_ca

; 243  : 
; 244  : 		// did we fine cylinder 0? if so, we are done
; 245  : 		if (!cyl) {

	jmp	SHORT $LN52@flpydsk_ca
$LN106@flpydsk_ca:

; 242  : 		flpydsk_check_int ( &st0, &cyl);

	push	1013					; 000003f5H
	call	?in_byte@@YAEG@Z			; in_byte
	add	esp, 4
$LN52@flpydsk_ca:
	xor	esi, esi
	npad	3
$LL62@flpydsk_ca:
	push	1012					; 000003f4H
	call	?in_byte@@YAEG@Z			; in_byte
	add	esp, 4
	test	al, al
	js	SHORT $LN107@flpydsk_ca
	add	esi, 1
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL62@flpydsk_ca
$LN108@flpydsk_ca:

; 246  : 
; 247  : 			flpydsk_control_motor (false);

	cmp	BYTE PTR __current_drive, 3
	ja	SHORT $LN76@flpydsk_ca
	push	4
	push	1010					; 000003f2H
	call	?out_byte@@YAXGE@Z			; out_byte
	push	20					; 00000014H
	call	?delay@@YAXI@Z				; delay
	add	esp, 12					; 0000000cH
$LN76@flpydsk_ca:
	pop	esi
	pop	edi

; 248  : 			return 0;

	xor	eax, eax
	pop	ebx

; 254  : }

	add	esp, 48					; 00000030H
	ret	0
$LN107@flpydsk_ca:

; 242  : 		flpydsk_check_int ( &st0, &cyl);

	push	1013					; 000003f5H
	call	?in_byte@@YAEG@Z			; in_byte
	add	esp, 4

; 243  : 
; 244  : 		// did we fine cylinder 0? if so, we are done
; 245  : 		if (!cyl) {

	test	al, al
	je	SHORT $LN108@flpydsk_ca
	add	edi, 1
	cmp	edi, 10					; 0000000aH
	jl	$LL4@flpydsk_ca

; 249  : 		}
; 250  : 	}
; 251  : 
; 252  : 	flpydsk_control_motor (false);

	cmp	BYTE PTR __current_drive, 3
	ja	SHORT $LN91@flpydsk_ca
	push	4
	push	1010					; 000003f2H
	call	?out_byte@@YAXGE@Z			; out_byte
	push	20					; 00000014H
	call	?delay@@YAXI@Z				; delay
	add	esp, 12					; 0000000cH
$LN91@flpydsk_ca:
	pop	esi
	pop	edi

; 253  : 	return -1;

	or	eax, -1
	pop	ebx

; 254  : }

	add	esp, 48					; 00000030H
	ret	0
	npad	2
$LN119@flpydsk_ca:
	DD	$LN13@flpydsk_ca
	DD	$LN12@flpydsk_ca
	DD	$LN11@flpydsk_ca
	DD	$LN10@flpydsk_ca
?flpydsk_calibrate@@YAHE@Z ENDP				; flpydsk_calibrate
_TEXT	ENDS
PUBLIC	?flpydsk_disable_controller@@YAXXZ		; flpydsk_disable_controller
; Function compile flags: /Ogtpy
;	COMDAT ?flpydsk_disable_controller@@YAXXZ
_TEXT	SEGMENT
?flpydsk_disable_controller@@YAXXZ PROC			; flpydsk_disable_controller, COMDAT

; 259  : 	flpydsk_write_dor (0);

	push	0
	push	1010					; 000003f2H
	call	?out_byte@@YAXGE@Z			; out_byte
	add	esp, 8

; 260  : }

	ret	0
?flpydsk_disable_controller@@YAXXZ ENDP			; flpydsk_disable_controller
_TEXT	ENDS
PUBLIC	?flpydsk_enable_controller@@YAXXZ		; flpydsk_enable_controller
; Function compile flags: /Ogtpy
;	COMDAT ?flpydsk_enable_controller@@YAXXZ
_TEXT	SEGMENT
?flpydsk_enable_controller@@YAXXZ PROC			; flpydsk_enable_controller, COMDAT

; 265  : 	flpydsk_write_dor ( FLPYDSK_DOR_MASK_RESET | FLPYDSK_DOR_MASK_DMA);

	push	12					; 0000000cH
	push	1010					; 000003f2H
	call	?out_byte@@YAXGE@Z			; out_byte
	add	esp, 8

; 266  : }

	ret	0
?flpydsk_enable_controller@@YAXXZ ENDP			; flpydsk_enable_controller
_TEXT	ENDS
PUBLIC	?flpydsk_reset@@YAXXZ				; flpydsk_reset
; Function compile flags: /Ogtpy
;	COMDAT ?flpydsk_reset@@YAXXZ
_TEXT	SEGMENT
_msg$3633 = -48						; size = 48
?flpydsk_reset@@YAXXZ PROC				; flpydsk_reset, COMDAT

; 270  : {

	sub	esp, 48					; 00000030H
	push	esi
	push	edi

; 271  : 	uint32_t st0, cyl;
; 272  : 
; 273  : 	// reset the controller
; 274  : 	flpydsk_disable_controller ();

	push	0
	push	1010					; 000003f2H
	call	?out_byte@@YAXGE@Z			; out_byte

; 275  : 	flpydsk_enable_controller ();

	push	12					; 0000000cH
	push	1010					; 000003f2H
	call	?out_byte@@YAXGE@Z			; out_byte

; 276  : 	flpydsk_wait_irq ();

	lea	eax, DWORD PTR _msg$3633[esp+72]
	push	eax
	push	-10					; fffffff6H
	push	2
	call	?send_recv@@YAHHHPAU_tagMESSAGE@@@Z	; send_recv
	add	esp, 28					; 0000001cH
	mov	edi, 4
$LL3@flpydsk_re@2:

; 280  : 		flpydsk_check_int (&st0,&cyl);

	xor	esi, esi
$LL21@flpydsk_re@2:
	push	1012					; 000003f4H
	call	?in_byte@@YAEG@Z			; in_byte
	add	esp, 4
	test	al, al
	js	SHORT $LN77@flpydsk_re@2
	add	esi, 1
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL21@flpydsk_re@2

; 284  : 
; 285  : 	// pass mechanical drive info. steprate=3ms, unload time=240ms, load time=16ms
; 286  : 	flpydsk_drive_data (3,16,240,true);

	jmp	SHORT $LN19@flpydsk_re@2
$LN77@flpydsk_re@2:

; 280  : 		flpydsk_check_int (&st0,&cyl);

	push	8
	push	1013					; 000003f5H
	call	?out_byte@@YAXGE@Z			; out_byte
	add	esp, 8
$LN19@flpydsk_re@2:
	xor	esi, esi
$LL29@flpydsk_re@2:
	push	1012					; 000003f4H
	call	?in_byte@@YAEG@Z			; in_byte
	add	esp, 4
	test	al, al
	js	SHORT $LN78@flpydsk_re@2
	add	esi, 1
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL29@flpydsk_re@2

; 284  : 
; 285  : 	// pass mechanical drive info. steprate=3ms, unload time=240ms, load time=16ms
; 286  : 	flpydsk_drive_data (3,16,240,true);

	jmp	SHORT $LN27@flpydsk_re@2
$LN78@flpydsk_re@2:

; 280  : 		flpydsk_check_int (&st0,&cyl);

	push	1013					; 000003f5H
	call	?in_byte@@YAEG@Z			; in_byte
	add	esp, 4
$LN27@flpydsk_re@2:
	xor	esi, esi
$LL37@flpydsk_re@2:
	push	1012					; 000003f4H
	call	?in_byte@@YAEG@Z			; in_byte
	add	esp, 4
	test	al, al
	js	SHORT $LN79@flpydsk_re@2
	add	esi, 1
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL37@flpydsk_re@2

; 284  : 
; 285  : 	// pass mechanical drive info. steprate=3ms, unload time=240ms, load time=16ms
; 286  : 	flpydsk_drive_data (3,16,240,true);

	jmp	SHORT $LN35@flpydsk_re@2
$LN79@flpydsk_re@2:

; 280  : 		flpydsk_check_int (&st0,&cyl);

	push	1013					; 000003f5H
	call	?in_byte@@YAEG@Z			; in_byte
	add	esp, 4
$LN35@flpydsk_re@2:

; 277  : 
; 278  : 	// send CHECK_INT/SENSE INTERRUPT command to all drives
; 279  : 	for (int i=0; i<4; i++)

	sub	edi, 1
	jne	$LL3@flpydsk_re@2

; 281  : 
; 282  : 	// transfer speed 500kb/s
; 283  : 	flpydsk_write_ccr (0);

	push	edi
	push	1015					; 000003f7H
	call	?out_byte@@YAXGE@Z			; out_byte
	add	esp, 8

; 284  : 
; 285  : 	// pass mechanical drive info. steprate=3ms, unload time=240ms, load time=16ms
; 286  : 	flpydsk_drive_data (3,16,240,true);

	xor	esi, esi
$LL49@flpydsk_re@2:
	push	1012					; 000003f4H
	call	?in_byte@@YAEG@Z			; in_byte
	add	esp, 4
	test	al, al
	js	SHORT $LN80@flpydsk_re@2
	add	esi, 1
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL49@flpydsk_re@2
	jmp	SHORT $LN47@flpydsk_re@2
$LN80@flpydsk_re@2:
	push	3
	push	1013					; 000003f5H
	call	?out_byte@@YAXGE@Z			; out_byte
	add	esp, 8
$LN47@flpydsk_re@2:
	xor	esi, esi
$LL57@flpydsk_re@2:
	push	1012					; 000003f4H
	call	?in_byte@@YAEG@Z			; in_byte
	add	esp, 4
	test	al, al
	js	SHORT $LN81@flpydsk_re@2
	add	esi, 1
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL57@flpydsk_re@2
	jmp	SHORT $LN55@flpydsk_re@2
$LN81@flpydsk_re@2:
	push	48					; 00000030H
	push	1013					; 000003f5H
	call	?out_byte@@YAXGE@Z			; out_byte
	add	esp, 8
$LN55@flpydsk_re@2:
	xor	esi, esi
$LL65@flpydsk_re@2:
	push	1012					; 000003f4H
	call	?in_byte@@YAEG@Z			; in_byte
	add	esp, 4
	test	al, al
	js	SHORT $LN82@flpydsk_re@2
	add	esi, 1
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL65@flpydsk_re@2
	jmp	SHORT $LN63@flpydsk_re@2
$LN82@flpydsk_re@2:
	push	32					; 00000020H
	push	1013					; 000003f5H
	call	?out_byte@@YAXGE@Z			; out_byte
	add	esp, 8
$LN63@flpydsk_re@2:

; 287  : 
; 288  : 	// calibrate the disk
; 289  : 	flpydsk_calibrate ( _current_drive );

	movzx	ecx, BYTE PTR __current_drive
	push	ecx
	call	?flpydsk_calibrate@@YAHE@Z		; flpydsk_calibrate
	add	esp, 4
	pop	edi
	pop	esi

; 290  : }

	add	esp, 48					; 00000030H
	ret	0
?flpydsk_reset@@YAXXZ ENDP				; flpydsk_reset
_TEXT	ENDS
PUBLIC	?flpydsk_read_sector_imp@@YAXEEE@Z		; flpydsk_read_sector_imp
; Function compile flags: /Ogtpy
;	COMDAT ?flpydsk_read_sector_imp@@YAXEEE@Z
_TEXT	SEGMENT
_msg$3805 = -48						; size = 48
_head$ = 8						; size = 1
_track$ = 12						; size = 1
_sector$ = 16						; size = 1
?flpydsk_read_sector_imp@@YAXEEE@Z PROC			; flpydsk_read_sector_imp, COMDAT

; 294  : {

	sub	esp, 48					; 00000030H
	push	ebx

; 295  : 	uint32_t st0, cyl;
; 296  : 
; 297  : 	// initialize DMA
; 298  : 	dma_initialize_floppy ((uint8_t*) DMA_BUFFER, 512 );

	push	512					; 00000200H
	push	4096					; 00001000H
	call	?dma_initialize_floppy@@YA_NPAEI@Z	; dma_initialize_floppy

; 299  : 
; 300  : 	// set the DMA for read transfer
; 301  : 	dma_set_read ( FDC_DMA_CHANNEL );

	push	2
	call	?dma_set_read@@YAXE@Z			; dma_set_read

; 302  : 
; 303  : 	// read in a sector
; 304  : 	flpydsk_send_command (
; 305  : 				FDC_CMD_READ_SECT | FDC_CMD_EXT_MULTITRACK | FDC_CMD_EXT_SKIP | FDC_CMD_EXT_DENSITY);

	push	230					; 000000e6H
	call	?flpydsk_send_command@@YAXE@Z		; flpydsk_send_command

; 306  : 	flpydsk_send_command ( head << 2 | _current_drive );

	mov	ebx, DWORD PTR _head$[esp+64]
	movzx	eax, bl
	add	al, al
	add	al, al
	or	al, BYTE PTR __current_drive
	push	eax
	call	?flpydsk_send_command@@YAXE@Z		; flpydsk_send_command

; 307  : 	flpydsk_send_command ( track);

	mov	ecx, DWORD PTR _track$[esp+68]
	push	ecx
	call	?flpydsk_send_command@@YAXE@Z		; flpydsk_send_command

; 308  : 	flpydsk_send_command ( head);

	push	ebx
	call	?flpydsk_send_command@@YAXE@Z		; flpydsk_send_command

; 309  : 	flpydsk_send_command ( sector);

	mov	ebx, DWORD PTR _sector$[esp+76]
	push	ebx
	call	?flpydsk_send_command@@YAXE@Z		; flpydsk_send_command

; 310  : 	flpydsk_send_command ( FLPYDSK_SECTOR_DTL_512 );

	push	2
	call	?flpydsk_send_command@@YAXE@Z		; flpydsk_send_command

; 311  : 	flpydsk_send_command ( ( ( sector + 1 ) >= FLPY_SECTORS_PER_TRACK ) ? FLPY_SECTORS_PER_TRACK : sector + 1 );

	movzx	eax, bl
	add	esp, 36					; 00000024H
	add	eax, 1
	cmp	eax, 18					; 00000012H
	pop	ebx
	jl	SHORT $LN6@flpydsk_re@3
	mov	eax, 18					; 00000012H
$LN6@flpydsk_re@3:
	push	esi
	push	edi
	push	eax
	call	?flpydsk_send_command@@YAXE@Z		; flpydsk_send_command

; 312  : 	flpydsk_send_command ( FLPYDSK_GAP3_LENGTH_3_5 );

	push	27					; 0000001bH
	call	?flpydsk_send_command@@YAXE@Z		; flpydsk_send_command

; 313  : 	flpydsk_send_command ( 0xff );

	push	255					; 000000ffH
	call	?flpydsk_send_command@@YAXE@Z		; flpydsk_send_command

; 314  : 
; 315  : 	// wait for irq
; 316  : 	flpydsk_wait_irq ();

	lea	edx, DWORD PTR _msg$3805[esp+68]
	push	edx
	push	-10					; fffffff6H
	push	2
	call	?send_recv@@YAHHHPAU_tagMESSAGE@@@Z	; send_recv
	add	esp, 24					; 00000018H
	mov	edi, 7
	npad	1
$LL3@flpydsk_re@3:

; 320  : 		flpydsk_read_data ();

	xor	esi, esi
$LL13@flpydsk_re@3:
	push	1012					; 000003f4H
	call	?in_byte@@YAEG@Z			; in_byte
	add	esp, 4
	test	al, al
	js	SHORT $LN49@flpydsk_re@3
	add	esi, 1
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL13@flpydsk_re@3

; 321  : 
; 322  : 	// let FDC know we handled interrupt
; 323  : 	flpydsk_check_int (&st0,&cyl);

	jmp	SHORT $LN2@flpydsk_re@3
$LN49@flpydsk_re@3:

; 320  : 		flpydsk_read_data ();

	push	1013					; 000003f5H
	call	?in_byte@@YAEG@Z			; in_byte
	add	esp, 4
$LN2@flpydsk_re@3:

; 317  : 
; 318  : 	// read status info
; 319  : 	for (int j=0; j<7; j++)

	sub	edi, 1
	jne	SHORT $LL3@flpydsk_re@3

; 321  : 
; 322  : 	// let FDC know we handled interrupt
; 323  : 	flpydsk_check_int (&st0,&cyl);

	xor	esi, esi
$LL23@flpydsk_re@3:
	push	1012					; 000003f4H
	call	?in_byte@@YAEG@Z			; in_byte
	add	esp, 4
	test	al, al
	js	SHORT $LN50@flpydsk_re@3
	add	esi, 1
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL23@flpydsk_re@3
	jmp	SHORT $LN21@flpydsk_re@3
$LN50@flpydsk_re@3:
	push	8
	push	1013					; 000003f5H
	call	?out_byte@@YAXGE@Z			; out_byte
	add	esp, 8
$LN21@flpydsk_re@3:
	xor	esi, esi
$LL31@flpydsk_re@3:
	push	1012					; 000003f4H
	call	?in_byte@@YAEG@Z			; in_byte
	add	esp, 4
	test	al, al
	js	SHORT $LN51@flpydsk_re@3
	add	esi, 1
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL31@flpydsk_re@3
	jmp	SHORT $LN29@flpydsk_re@3
$LN51@flpydsk_re@3:
	push	1013					; 000003f5H
	call	?in_byte@@YAEG@Z			; in_byte
	add	esp, 4
$LN29@flpydsk_re@3:
	xor	esi, esi
$LL39@flpydsk_re@3:
	push	1012					; 000003f4H
	call	?in_byte@@YAEG@Z			; in_byte
	add	esp, 4
	test	al, al
	js	SHORT $LN52@flpydsk_re@3
	add	esi, 1
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL39@flpydsk_re@3
	pop	edi
	pop	esi

; 324  : }

	add	esp, 48					; 00000030H
	ret	0
$LN52@flpydsk_re@3:

; 321  : 
; 322  : 	// let FDC know we handled interrupt
; 323  : 	flpydsk_check_int (&st0,&cyl);

	push	1013					; 000003f5H
	call	?in_byte@@YAEG@Z			; in_byte
	add	esp, 4
	pop	edi
	pop	esi

; 324  : }

	add	esp, 48					; 00000030H
	ret	0
?flpydsk_read_sector_imp@@YAXEEE@Z ENDP			; flpydsk_read_sector_imp
_TEXT	ENDS
PUBLIC	?flpydsk_seek@@YAHEE@Z				; flpydsk_seek
; Function compile flags: /Ogtpy
;	COMDAT ?flpydsk_seek@@YAHEE@Z
_TEXT	SEGMENT
tv231 = -53						; size = 1
$T3933 = -52						; size = 1
_msg$3949 = -48						; size = 48
_cyl$ = 8						; size = 1
_head$ = 12						; size = 1
?flpydsk_seek@@YAHEE@Z PROC				; flpydsk_seek, COMDAT

; 328  : {

	sub	esp, 56					; 00000038H

; 329  : 	uint32_t st0, cyl0;
; 330  : 
; 331  : 	if (_current_drive >= 4)

	cmp	BYTE PTR __current_drive, 4
	jb	SHORT $LN5@flpydsk_se@2

; 332  : 		return -1;

	or	eax, -1

; 351  : }

	add	esp, 56					; 00000038H
	ret	0
$LN5@flpydsk_se@2:

; 333  : 
; 334  : 	for (int i = 0; i < 10; i++ ) {

	mov	al, BYTE PTR _head$[esp+52]
	push	ebx
	mov	ebx, DWORD PTR _cyl$[esp+56]
	push	edi
	add	al, al
	xor	edi, edi
	add	al, al
	mov	BYTE PTR tv231[esp+64], al
	push	esi
	npad	8
$LL4@flpydsk_se@2:

; 335  : 
; 336  : 		// send the command
; 337  : 		flpydsk_send_command (FDC_CMD_SEEK);

	xor	esi, esi
$LL11@flpydsk_se@2:
	push	1012					; 000003f4H
	call	?in_byte@@YAEG@Z			; in_byte
	add	esp, 4
	test	al, al
	js	SHORT $LN67@flpydsk_se@2
	add	esi, 1
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL11@flpydsk_se@2

; 344  : 
; 345  : 		// found the cylinder?
; 346  : 		if ( cyl0 == cyl)

	jmp	SHORT $LN9@flpydsk_se@2
$LN67@flpydsk_se@2:

; 335  : 
; 336  : 		// send the command
; 337  : 		flpydsk_send_command (FDC_CMD_SEEK);

	push	15					; 0000000fH
	push	1013					; 000003f5H
	call	?out_byte@@YAXGE@Z			; out_byte
	add	esp, 8
$LN9@flpydsk_se@2:

; 338  : 		flpydsk_send_command ((head) << 2 | _current_drive);

	mov	al, BYTE PTR tv231[esp+68]
	or	al, BYTE PTR __current_drive
	xor	esi, esi
	mov	BYTE PTR $T3933[esp+68], al
	npad	1
$LL19@flpydsk_se@2:
	push	1012					; 000003f4H
	call	?in_byte@@YAEG@Z			; in_byte
	add	esp, 4
	test	al, al
	js	SHORT $LN68@flpydsk_se@2
	add	esi, 1
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL19@flpydsk_se@2

; 344  : 
; 345  : 		// found the cylinder?
; 346  : 		if ( cyl0 == cyl)

	jmp	SHORT $LN17@flpydsk_se@2
$LN68@flpydsk_se@2:

; 338  : 		flpydsk_send_command ((head) << 2 | _current_drive);

	mov	ecx, DWORD PTR $T3933[esp+68]
	push	ecx
	push	1013					; 000003f5H
	call	?out_byte@@YAXGE@Z			; out_byte
	add	esp, 8
$LN17@flpydsk_se@2:

; 339  : 		flpydsk_send_command (cyl);

	xor	esi, esi
$LL27@flpydsk_se@2:
	push	1012					; 000003f4H
	call	?in_byte@@YAEG@Z			; in_byte
	add	esp, 4
	test	al, al
	js	SHORT $LN69@flpydsk_se@2
	add	esi, 1
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL27@flpydsk_se@2

; 344  : 
; 345  : 		// found the cylinder?
; 346  : 		if ( cyl0 == cyl)

	jmp	SHORT $LN25@flpydsk_se@2
$LN69@flpydsk_se@2:

; 339  : 		flpydsk_send_command (cyl);

	push	ebx
	push	1013					; 000003f5H
	call	?out_byte@@YAXGE@Z			; out_byte
	add	esp, 8
$LN25@flpydsk_se@2:

; 340  : 
; 341  : 		// wait for the results phase IRQ
; 342  : 		flpydsk_wait_irq ();

	lea	edx, DWORD PTR _msg$3949[esp+68]
	push	edx
	push	-10					; fffffff6H
	push	2
	call	?send_recv@@YAHHHPAU_tagMESSAGE@@@Z	; send_recv
	add	esp, 12					; 0000000cH

; 343  : 		flpydsk_check_int (&st0,&cyl0);

	xor	esi, esi
$LL39@flpydsk_se@2:
	push	1012					; 000003f4H
	call	?in_byte@@YAEG@Z			; in_byte
	add	esp, 4
	test	al, al
	js	SHORT $LN70@flpydsk_se@2
	add	esi, 1
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL39@flpydsk_se@2

; 344  : 
; 345  : 		// found the cylinder?
; 346  : 		if ( cyl0 == cyl)

	jmp	SHORT $LN37@flpydsk_se@2
$LN70@flpydsk_se@2:

; 343  : 		flpydsk_check_int (&st0,&cyl0);

	push	8
	push	1013					; 000003f5H
	call	?out_byte@@YAXGE@Z			; out_byte
	add	esp, 8
$LN37@flpydsk_se@2:
	xor	esi, esi
$LL47@flpydsk_se@2:
	push	1012					; 000003f4H
	call	?in_byte@@YAEG@Z			; in_byte
	add	esp, 4
	test	al, al
	js	SHORT $LN71@flpydsk_se@2
	add	esi, 1
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL47@flpydsk_se@2

; 344  : 
; 345  : 		// found the cylinder?
; 346  : 		if ( cyl0 == cyl)

	jmp	SHORT $LN45@flpydsk_se@2
$LN71@flpydsk_se@2:

; 343  : 		flpydsk_check_int (&st0,&cyl0);

	push	1013					; 000003f5H
	call	?in_byte@@YAEG@Z			; in_byte
	add	esp, 4
$LN45@flpydsk_se@2:
	xor	esi, esi
	npad	3
$LL55@flpydsk_se@2:
	push	1012					; 000003f4H
	call	?in_byte@@YAEG@Z			; in_byte
	add	esp, 4
	test	al, al
	js	SHORT $LN72@flpydsk_se@2
	add	esi, 1
	cmp	esi, 500				; 000001f4H
	jl	SHORT $LL55@flpydsk_se@2
	xor	al, al
$LN56@flpydsk_se@2:

; 344  : 
; 345  : 		// found the cylinder?
; 346  : 		if ( cyl0 == cyl)

	cmp	al, bl
	je	SHORT $LN73@flpydsk_se@2
	add	edi, 1
	cmp	edi, 10					; 0000000aH
	jl	$LL4@flpydsk_se@2
	pop	esi
	pop	edi

; 348  : 	}
; 349  : 
; 350  : 	return -1;

	or	eax, -1
	pop	ebx

; 351  : }

	add	esp, 56					; 00000038H
	ret	0
$LN72@flpydsk_se@2:

; 343  : 		flpydsk_check_int (&st0,&cyl0);

	push	1013					; 000003f5H
	call	?in_byte@@YAEG@Z			; in_byte
	add	esp, 4
	jmp	SHORT $LN56@flpydsk_se@2
$LN73@flpydsk_se@2:
	pop	esi
	pop	edi

; 347  : 			return 0;

	xor	eax, eax
	pop	ebx

; 351  : }

	add	esp, 56					; 00000038H
	ret	0
?flpydsk_seek@@YAHEE@Z ENDP				; flpydsk_seek
_TEXT	ENDS
PUBLIC	?flpydsk_lba_to_chs@@YAXHPAH00@Z		; flpydsk_lba_to_chs
; Function compile flags: /Ogtpy
;	COMDAT ?flpydsk_lba_to_chs@@YAXHPAH00@Z
_TEXT	SEGMENT
_lba$ = 8						; size = 4
_head$ = 12						; size = 4
_track$ = 16						; size = 4
_sector$ = 20						; size = 4
?flpydsk_lba_to_chs@@YAXHPAH00@Z PROC			; flpydsk_lba_to_chs, COMDAT

; 355  :    *head = ( lba % ( FLPY_SECTORS_PER_TRACK * 2 ) ) / ( FLPY_SECTORS_PER_TRACK );

	mov	ecx, DWORD PTR _lba$[esp-4]
	mov	eax, 954437177				; 38e38e39H
	imul	ecx
	sar	edx, 3
	push	esi
	mov	esi, edx
	shr	esi, 31					; 0000001fH
	add	esi, edx
	lea	eax, DWORD PTR [esi+esi*8]
	add	eax, eax
	add	eax, eax
	mov	edx, ecx
	sub	edx, eax
	mov	eax, 954437177				; 38e38e39H
	imul	edx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	edx, DWORD PTR _head$[esp]
	mov	DWORD PTR [edx], eax

; 356  :    *track = lba / ( FLPY_SECTORS_PER_TRACK * 2 );

	mov	eax, DWORD PTR _track$[esp]
	mov	DWORD PTR [eax], esi

; 357  :    *sector = lba % FLPY_SECTORS_PER_TRACK + 1;

	mov	eax, 954437177				; 38e38e39H
	imul	ecx
	sar	edx, 2
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	lea	edx, DWORD PTR [eax+eax*8]
	mov	eax, DWORD PTR _sector$[esp]
	add	edx, edx
	sub	ecx, edx
	add	ecx, 1
	mov	DWORD PTR [eax], ecx
	pop	esi

; 358  : }

	ret	0
?flpydsk_lba_to_chs@@YAXHPAH00@Z ENDP			; flpydsk_lba_to_chs
_TEXT	ENDS
PUBLIC	?flpydsk_install@@YAXH@Z			; flpydsk_install
EXTRN	?init_idt_desc@@YAXIP6AXXZEEG@Z:PROC		; init_idt_desc
; Function compile flags: /Ogtpy
;	COMDAT ?flpydsk_install@@YAXH@Z
_TEXT	SEGMENT
_irq$ = 8						; size = 4
?flpydsk_install@@YAXH@Z PROC				; flpydsk_install, COMDAT

; 363  : 	init_idt_desc(irq,i86_flpy_irq,DA_386IGATE,PRIVILEGE_KRNL,0x08);

	mov	eax, DWORD PTR _irq$[esp-4]
	push	8
	push	0
	push	142					; 0000008eH
	push	OFFSET ?i86_flpy_irq@@YAXXZ		; i86_flpy_irq
	push	eax
	call	?init_idt_desc@@YAXIP6AXXZEEG@Z		; init_idt_desc

; 364  : 
; 365  : 	// reset the fdc
; 366  : 	flpydsk_reset ();

	call	?flpydsk_reset@@YAXXZ			; flpydsk_reset

; 367  : 
; 368  : 	// set drive information
; 369  : 	flpydsk_drive_data (13, 1, 0xf, true);

	push	3
	call	?flpydsk_send_command@@YAXE@Z		; flpydsk_send_command
	push	223					; 000000dfH
	call	?flpydsk_send_command@@YAXE@Z		; flpydsk_send_command
	add	esp, 28					; 0000001cH
	mov	DWORD PTR _irq$[esp-4], 2
	jmp	?flpydsk_send_command@@YAXE@Z		; flpydsk_send_command
?flpydsk_install@@YAXH@Z ENDP				; flpydsk_install
_TEXT	ENDS
PUBLIC	?flpydsk_set_working_drive@@YAXE@Z		; flpydsk_set_working_drive
; Function compile flags: /Ogtpy
;	COMDAT ?flpydsk_set_working_drive@@YAXE@Z
_TEXT	SEGMENT
_drive$ = 8						; size = 1
?flpydsk_set_working_drive@@YAXE@Z PROC			; flpydsk_set_working_drive, COMDAT

; 374  : 
; 375  : 	if (drive < 4)

	mov	al, BYTE PTR _drive$[esp-4]
	cmp	al, 4
	jae	SHORT $LN1@flpydsk_se@3

; 376  : 		_current_drive = drive;

	mov	BYTE PTR __current_drive, al
$LN1@flpydsk_se@3:

; 377  : }

	ret	0
?flpydsk_set_working_drive@@YAXE@Z ENDP			; flpydsk_set_working_drive
_TEXT	ENDS
PUBLIC	?flpydsk_get_working_drive@@YAEXZ		; flpydsk_get_working_drive
; Function compile flags: /Ogtpy
;	COMDAT ?flpydsk_get_working_drive@@YAEXZ
_TEXT	SEGMENT
?flpydsk_get_working_drive@@YAEXZ PROC			; flpydsk_get_working_drive, COMDAT

; 382  : 	return _current_drive;

	mov	al, BYTE PTR __current_drive

; 383  : }

	ret	0
?flpydsk_get_working_drive@@YAEXZ ENDP			; flpydsk_get_working_drive
_TEXT	ENDS
PUBLIC	?flpydsk_read_sector@@YAPAEH@Z			; flpydsk_read_sector
; Function compile flags: /Ogtpy
;	COMDAT ?flpydsk_read_sector@@YAPAEH@Z
_TEXT	SEGMENT
_head$ = -12						; size = 4
_track$ = -8						; size = 4
_sector$ = -4						; size = 4
_sectorLBA$ = 8						; size = 4
?flpydsk_read_sector@@YAPAEH@Z PROC			; flpydsk_read_sector, COMDAT

; 387  : {

	sub	esp, 12					; 0000000cH
	push	ebx

; 388  : 	if (_current_drive >= 4)

	mov	bl, BYTE PTR __current_drive

; 389  : 		return 0;

	xor	eax, eax
	cmp	bl, 4
	jae	$LN3@flpydsk_re@4

; 390  : 
; 391  : 	// convert LBA sector to CHS
; 392  : 	int head=0, track=0, sector=1;

	mov	DWORD PTR _head$[esp+16], eax
	mov	DWORD PTR _track$[esp+16], eax

; 393  : 	flpydsk_lba_to_chs (sectorLBA, &head, &track, &sector);

	lea	eax, DWORD PTR _sector$[esp+16]
	push	eax
	mov	eax, DWORD PTR _sectorLBA$[esp+16]
	lea	ecx, DWORD PTR _track$[esp+20]
	push	ecx
	lea	edx, DWORD PTR _head$[esp+24]
	push	edx
	push	eax
	mov	DWORD PTR _sector$[esp+32], 1
	call	?flpydsk_lba_to_chs@@YAXHPAH00@Z	; flpydsk_lba_to_chs
	add	esp, 16					; 00000010H

; 394  : 
; 395  : 	// turn motor on and seek to track
; 396  : 	flpydsk_control_motor (true);

	cmp	bl, 3
	ja	SHORT $LN14@flpydsk_re@4
	movzx	ecx, bl
	xor	al, al
	cmp	ecx, 3
	ja	SHORT $LN11@flpydsk_re@4
	jmp	DWORD PTR $LN37@flpydsk_re@4[ecx*4]
$LN10@flpydsk_re@4:
	mov	al, 16					; 00000010H
	jmp	SHORT $LN11@flpydsk_re@4
$LN9@flpydsk_re@4:
	mov	al, 32					; 00000020H
	jmp	SHORT $LN11@flpydsk_re@4
$LN8@flpydsk_re@4:
	mov	al, 64					; 00000040H
	jmp	SHORT $LN11@flpydsk_re@4
$LN7@flpydsk_re@4:
	mov	al, 128					; 00000080H
$LN11@flpydsk_re@4:
	or	bl, al
	or	ebx, 12					; 0000000cH
	push	ebx
	push	1010					; 000003f2H
	call	?out_byte@@YAXGE@Z			; out_byte
	push	20					; 00000014H
	call	?delay@@YAXI@Z				; delay
	add	esp, 12					; 0000000cH
$LN14@flpydsk_re@4:
	push	esi

; 397  : 	if (flpydsk_seek ((uint8_t)track, (uint8_t)head) != 0)

	mov	esi, DWORD PTR _head$[esp+20]
	push	edi
	mov	edi, DWORD PTR _track$[esp+24]
	push	esi
	push	edi
	call	?flpydsk_seek@@YAHEE@Z			; flpydsk_seek
	add	esp, 8
	test	eax, eax
	je	SHORT $LN1@flpydsk_re@4
	pop	edi
	pop	esi

; 398  : 		return 0;

	xor	eax, eax
	pop	ebx

; 405  : }

	add	esp, 12					; 0000000cH
	ret	0
$LN1@flpydsk_re@4:

; 399  : 	// read sector and turn motor off
; 400  : 	flpydsk_read_sector_imp ((uint8_t)head, (uint8_t)track, (uint8_t)sector);

	mov	ecx, DWORD PTR _sector$[esp+24]
	push	ecx
	push	edi
	push	esi
	call	?flpydsk_read_sector_imp@@YAXEEE@Z	; flpydsk_read_sector_imp
	add	esp, 12					; 0000000cH

; 401  : 	flpydsk_control_motor (false);

	cmp	BYTE PTR __current_drive, 3
	ja	SHORT $LN29@flpydsk_re@4
	push	4
	push	1010					; 000003f2H
	call	?out_byte@@YAXGE@Z			; out_byte
	push	20					; 00000014H
	call	?delay@@YAXI@Z				; delay
	add	esp, 12					; 0000000cH
$LN29@flpydsk_re@4:
	pop	edi

; 402  : 
; 403  : 	// warning: this is a bit hackish
; 404  : 	return (uint8_t*) DMA_BUFFER;

	mov	eax, 4096				; 00001000H
	pop	esi
$LN3@flpydsk_re@4:
	pop	ebx

; 405  : }

	add	esp, 12					; 0000000cH
	ret	0
	npad	2
$LN37@flpydsk_re@4:
	DD	$LN10@flpydsk_re@4
	DD	$LN9@flpydsk_re@4
	DD	$LN8@flpydsk_re@4
	DD	$LN7@flpydsk_re@4
?flpydsk_read_sector@@YAPAEH@Z ENDP			; flpydsk_read_sector
_TEXT	ENDS
PUBLIC	?flpy_do_read_sector@@YAPAEH@Z			; flpy_do_read_sector
; Function compile flags: /Ogtpy
;	COMDAT ?flpy_do_read_sector@@YAPAEH@Z
_TEXT	SEGMENT
_msg$ = -48						; size = 48
_sectorLBA$ = 8						; size = 4
?flpy_do_read_sector@@YAPAEH@Z PROC			; flpy_do_read_sector, COMDAT

; 408  : {

	sub	esp, 48					; 00000030H

; 409  : 	MESSAGE msg;
; 410  : 
; 411  : 	msg.type = DEV_READ;
; 412  : 	msg.SECTOR = sectorLBA;

	mov	eax, DWORD PTR _sectorLBA$[esp+44]
	cdq
	mov	DWORD PTR _msg$[esp+72], eax

; 413  : 	send_recv(BOTH,TASK_FLPY,&msg);

	lea	eax, DWORD PTR _msg$[esp+48]
	push	eax
	push	2
	push	3
	mov	DWORD PTR _msg$[esp+64], 1003		; 000003ebH
	mov	DWORD PTR _msg$[esp+88], edx
	call	?send_recv@@YAHHHPAU_tagMESSAGE@@@Z	; send_recv

; 414  : 
; 415  : 	return (uint8_t*)msg.BUF;

	mov	eax, DWORD PTR _msg$[esp+104]

; 416  : }

	add	esp, 60					; 0000003cH
	ret	0
?flpy_do_read_sector@@YAPAEH@Z ENDP			; flpy_do_read_sector
_TEXT	ENDS
PUBLIC	??_C@_0BF@BKAPIIHL@Floppy?5initialized?4?6?$AA@	; `string'
PUBLIC	?task_flpy@@YAXXZ				; task_flpy
EXTRN	?DbgPrintf@@YAHPBDZZ:PROC			; DbgPrintf
EXTRN	?enable_irq@@YAXH@Z:PROC			; enable_irq
;	COMDAT ??_C@_0BF@BKAPIIHL@Floppy?5initialized?4?6?$AA@
CONST	SEGMENT
??_C@_0BF@BKAPIIHL@Floppy?5initialized?4?6?$AA@ DB 'Floppy initialized.', 0aH
	DB	00H						; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?task_flpy@@YAXXZ
_TEXT	SEGMENT
_msg$ = -48						; size = 48
?task_flpy@@YAXXZ PROC					; task_flpy, COMDAT

; 12   : {

	sub	esp, 48					; 00000030H
	push	esi

; 13   : 	MESSAGE	msg;
; 14   : 
; 15   : 	//	set drive 0 as current drive
; 16   : 	flpydsk_set_working_drive (0);
; 17   : 
; 18   : 	enable_irq(FLOPPY_IRQ);

	push	6
	mov	BYTE PTR __current_drive, 0
	call	?enable_irq@@YAXH@Z			; enable_irq

; 19   : 	//	install floppy disk to IR 38, uses IRQ 6
; 20   : 	flpydsk_install (38);

	push	8
	push	0
	push	142					; 0000008eH
	push	OFFSET ?i86_flpy_irq@@YAXXZ		; i86_flpy_irq
	push	38					; 00000026H
	call	?init_idt_desc@@YAXIP6AXXZEEG@Z		; init_idt_desc
	call	?flpydsk_reset@@YAXXZ			; flpydsk_reset
	push	3
	call	?flpydsk_send_command@@YAXE@Z		; flpydsk_send_command
	push	223					; 000000dfH
	call	?flpydsk_send_command@@YAXE@Z		; flpydsk_send_command
	push	2
	call	?flpydsk_send_command@@YAXE@Z		; flpydsk_send_command

; 21   : 	DbgPrintf("Floppy initialized.\n");

	push	OFFSET ??_C@_0BF@BKAPIIHL@Floppy?5initialized?4?6?$AA@
	call	?DbgPrintf@@YAHPBDZZ			; DbgPrintf
	add	esp, 40					; 00000028H
$LL9@task_flpy:

; 22   : 
; 23   : //	send_recv(BOTH,TASK_FS,&msg);
; 24   : 
; 25   : 	while(1){
; 26   : 		send_recv(RECEIVE,ANY_TASK,&msg);

	lea	eax, DWORD PTR _msg$[esp+52]
	push	eax
	push	46					; 0000002eH
	push	2
	call	?send_recv@@YAHHHPAU_tagMESSAGE@@@Z	; send_recv

; 27   : 
; 28   : 		int src = msg.source;

	mov	esi, DWORD PTR _msg$[esp+64]
	add	esp, 12					; 0000000cH

; 29   : 
; 30   : 		switch(msg.type){

	cmp	DWORD PTR _msg$[esp+56], 1003		; 000003ebH
	jne	SHORT $LN6@task_flpy

; 31   : 			case DEV_OPEN:
; 32   : 				break;
; 33   : 			case DEV_READ:
; 34   : 				{
; 35   : 					//DbgPrintf("%d ",msg.SECTOR);
; 36   : 					msg.BUF = (void*)flpydsk_read_sector(msg.SECTOR);

	mov	ecx, DWORD PTR _msg$[esp+76]
	push	ecx
	call	?flpydsk_read_sector@@YAPAEH@Z		; flpydsk_read_sector
	add	esp, 4
	mov	DWORD PTR _msg$[esp+96], eax
$LN6@task_flpy:

; 37   : 					//uint8_t* buf;
; 38   : 					//buf = (uint8_t*)msg.BUF;
; 39   : 					//int i;
; 40   : 					//for(i = 0; i < 512; i++){
; 41   : 					//	DbgPrintf("%x",buf[i]);
; 42   : 					//}
; 43   : 				}
; 44   : 				break;
; 45   : 			case DEV_WRITE:
; 46   : 				break;
; 47   : 			case DEV_CLOSE:
; 48   : 				break;
; 49   : 			default:
; 50   : 				break;
; 51   : 		}
; 52   : 		send_recv(SEND,src,&msg);

	lea	edx, DWORD PTR _msg$[esp+52]
	push	edx
	push	esi
	push	1
	call	?send_recv@@YAHHHPAU_tagMESSAGE@@@Z	; send_recv
	add	esp, 12					; 0000000cH

; 53   : 	}

	jmp	SHORT $LL9@task_flpy
?task_flpy@@YAXXZ ENDP					; task_flpy
_TEXT	ENDS
END
