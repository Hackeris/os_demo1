; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	i:\os\10\a\krnl\krnl\vsprintf.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?vsprintf@@YAHPADPBDPAE@Z			; vsprintf
EXTRN	?strcpy@@YAPADPADPBD@Z:PROC			; strcpy
EXTRN	?itoa_s@@YAXHIPAD@Z:PROC			; itoa_s
EXTRN	?strlen@@YAIPBD@Z:PROC				; strlen
; Function compile flags: /Ogtpy
; File i:\os\10\a\krnl\krnl\vsprintf.cpp
;	COMDAT ?vsprintf@@YAHPADPBDPAE@Z
_TEXT	SEGMENT
_s$3002 = -32						; size = 32
_s$2991 = -32						; size = 32
_s$2981 = -32						; size = 32
_str$ = 8						; size = 4
_format$ = 12						; size = 4
_ap$ = 16						; size = 4
?vsprintf@@YAHPADPBDPAE@Z PROC				; vsprintf, COMDAT

; 5    : int vsprintf(char *str, const char *format, va_list ap) {

	sub	esp, 32					; 00000020H
	push	ebx

; 6    : 
; 7    : 	if (!str)

	mov	ebx, DWORD PTR _str$[esp+32]
	test	ebx, ebx
	jne	SHORT $LN13@vsprintf
$LN21@vsprintf:

; 8    : 		return 0;

	xor	eax, eax
	pop	ebx

; 70   : }

	add	esp, 32					; 00000020H
	ret	0
$LN13@vsprintf:

; 9    : 	if (!format)

	mov	eax, DWORD PTR _format$[esp+32]
	test	eax, eax

; 10   : 		return 0;

	je	SHORT $LN21@vsprintf
	push	ebp
	push	esi
	push	edi

; 11   : 	size_t loc=0;
; 12   : 	size_t i;
; 13   : 
; 14   : 	for (i=0 ; i<=strlen(format);i++, loc++)

	push	eax
	xor	esi, esi
	xor	ebp, ebp
	call	?strlen@@YAIPBD@Z			; strlen
	mov	edi, DWORD PTR _ap$[esp+48]
	add	esp, 4
	add	edi, -4					; fffffffcH
$LL11@vsprintf:

; 15   : 	{
; 16   : 		if(format[i] != '%') {

	mov	ecx, DWORD PTR _format$[esp+44]
	mov	al, BYTE PTR [ecx+ebp]
	cmp	al, 37					; 00000025H
	je	SHORT $LN8@vsprintf

; 17   : 			str[loc] = format[i];

	mov	BYTE PTR [esi+ebx], al

; 18   : 			continue;

	jmp	$LN10@vsprintf
$LN8@vsprintf:

; 19   : 		}
; 20   : 		switch (format[i+1])

	movsx	eax, BYTE PTR [ecx+ebp+1]
	add	eax, -88				; ffffffa8H
	cmp	eax, 32					; 00000020H
	ja	$LN10@vsprintf
	movzx	eax, BYTE PTR $LN18@vsprintf[eax]
	jmp	DWORD PTR $LN22@vsprintf[eax*4]
$LN5@vsprintf:

; 21   : 		{
; 22   : 		/*** characters ***/
; 23   : 		case 'c': {
; 24   : 			char c = va_arg (ap, char);
; 25   : 			str[loc] = c;

	mov	cl, BYTE PTR [edi+4]
	add	edi, 4
	mov	BYTE PTR [esi+ebx], cl

; 26   : 			i++;

	add	ebp, 1

; 27   : 			break;

	jmp	$LN10@vsprintf
$LN4@vsprintf:

; 28   : 		}
; 29   : 
; 30   : 		/*** integers ***/
; 31   : 		case 'd':
; 32   : 		case 'i': {
; 33   : 			int c = va_arg (ap, int);
; 34   : 			char s[32]={0};

	xor	eax, eax

; 35   : 			itoa_s (c, 10, s);

	lea	edx, DWORD PTR _s$2981[esp+48]
	push	edx
	add	edi, 4
	mov	DWORD PTR _s$2981[esp+53], eax
	mov	DWORD PTR _s$2981[esp+57], eax
	mov	DWORD PTR _s$2981[esp+61], eax
	mov	DWORD PTR _s$2981[esp+65], eax
	mov	DWORD PTR _s$2981[esp+69], eax
	mov	DWORD PTR _s$2981[esp+73], eax
	mov	DWORD PTR _s$2981[esp+77], eax
	mov	WORD PTR _s$2981[esp+81], ax
	mov	BYTE PTR _s$2981[esp+83], al
	mov	eax, DWORD PTR [edi]
	push	10					; 0000000aH
	push	eax
	mov	BYTE PTR _s$2981[esp+60], 0
	call	?itoa_s@@YAXHIPAD@Z			; itoa_s

; 36   : 			strcpy (&str[loc], s);

	lea	ecx, DWORD PTR _s$2981[esp+60]
	push	ecx
	lea	edx, DWORD PTR [esi+ebx]
	push	edx
	call	?strcpy@@YAPADPADPBD@Z			; strcpy

; 37   : 			loc+= strlen(s) - 2;

	lea	eax, DWORD PTR _s$2981[esp+68]
	push	eax
	call	?strlen@@YAIPBD@Z			; strlen
	add	esp, 24					; 00000018H

; 38   : 			i++;		// go to next character

	add	ebp, 1

; 39   : 			break;

	jmp	$LN20@vsprintf
$LN3@vsprintf:

; 40   : 		}
; 41   : 
; 42   : 		/*** display in hex ***/
; 43   : 		case 'X':
; 44   : 		case 'x': {
; 45   : 			int c = va_arg (ap, int);
; 46   : 			char s[32]={0};
; 47   : 			itoa_s (c,16,s);

	mov	edx, DWORD PTR [edi+4]
	xor	eax, eax
	lea	ecx, DWORD PTR _s$2991[esp+48]
	push	ecx
	add	edi, 4
	push	16					; 00000010H
	push	edx
	mov	BYTE PTR _s$2991[esp+60], 0
	mov	DWORD PTR _s$2991[esp+61], eax
	mov	DWORD PTR _s$2991[esp+65], eax
	mov	DWORD PTR _s$2991[esp+69], eax
	mov	DWORD PTR _s$2991[esp+73], eax
	mov	DWORD PTR _s$2991[esp+77], eax
	mov	DWORD PTR _s$2991[esp+81], eax
	mov	DWORD PTR _s$2991[esp+85], eax
	mov	WORD PTR _s$2991[esp+89], ax
	mov	BYTE PTR _s$2991[esp+91], al
	call	?itoa_s@@YAXHIPAD@Z			; itoa_s

; 48   : 			strcpy (&str[loc], s);

	lea	eax, DWORD PTR _s$2991[esp+60]
	push	eax
	lea	ecx, DWORD PTR [esi+ebx]
	push	ecx
	call	?strcpy@@YAPADPADPBD@Z			; strcpy

; 49   : 			i++;		// go to next character
; 50   : 			loc+=strlen(s) - 2;

	lea	edx, DWORD PTR _s$2991[esp+68]
	push	edx
	add	ebp, 1
	call	?strlen@@YAIPBD@Z			; strlen
	add	esp, 24					; 00000018H

; 51   : 			break;

	jmp	SHORT $LN20@vsprintf
$LN2@vsprintf:

; 52   : 		}
; 53   : 
; 54   : 		/*** strings ***/
; 55   : 		case 's': {
; 56   : 			int c = (int&) va_arg (ap, char);
; 57   : 			char s[32]={0};

	xor	eax, eax
	add	edi, 4
	mov	DWORD PTR _s$3002[esp+49], eax
	mov	DWORD PTR _s$3002[esp+53], eax
	mov	DWORD PTR _s$3002[esp+57], eax
	mov	DWORD PTR _s$3002[esp+61], eax
	mov	DWORD PTR _s$3002[esp+65], eax
	mov	DWORD PTR _s$3002[esp+69], eax
	mov	DWORD PTR _s$3002[esp+73], eax
	mov	WORD PTR _s$3002[esp+77], ax
	mov	BYTE PTR _s$3002[esp+79], al

; 58   : 			strcpy (s,(const char*)c);						

	mov	eax, DWORD PTR [edi]
	push	eax
	lea	ecx, DWORD PTR _s$3002[esp+52]
	push	ecx
	mov	BYTE PTR _s$3002[esp+56], 0
	call	?strcpy@@YAPADPADPBD@Z			; strcpy

; 59   : 			strcpy (&str[loc], s);

	lea	edx, DWORD PTR _s$3002[esp+56]
	push	edx
	lea	eax, DWORD PTR [esi+ebx]
	push	eax
	call	?strcpy@@YAPADPADPBD@Z			; strcpy

; 60   : 			i++;		// go to next character
; 61   : 			loc+=strlen(s) - 2;

	lea	ecx, DWORD PTR _s$3002[esp+64]
	push	ecx
	add	ebp, 1
	call	?strlen@@YAIPBD@Z			; strlen
	add	esp, 20					; 00000014H
$LN20@vsprintf:
	lea	esi, DWORD PTR [esi+eax-2]
$LN10@vsprintf:

; 11   : 	size_t loc=0;
; 12   : 	size_t i;
; 13   : 
; 14   : 	for (i=0 ; i<=strlen(format);i++, loc++)

	mov	edx, DWORD PTR _format$[esp+44]
	push	edx
	add	ebp, 1
	add	esi, 1
	call	?strlen@@YAIPBD@Z			; strlen
	add	esp, 4
	cmp	ebp, eax
	jbe	$LL11@vsprintf
	pop	edi

; 62   : 			break;
; 63   : 		}
; 64   : 		default:
; 65   : 			break;
; 66   : 		}
; 67   : 	}
; 68   : 
; 69   : 	return loc - 2;

	lea	eax, DWORD PTR [esi-2]
	pop	esi
	pop	ebp
	pop	ebx

; 70   : }

	add	esp, 32					; 00000020H
	ret	0
	npad	3
$LN22@vsprintf:
	DD	$LN3@vsprintf
	DD	$LN5@vsprintf
	DD	$LN4@vsprintf
	DD	$LN2@vsprintf
	DD	$LN10@vsprintf
$LN18@vsprintf:
	DB	0
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	1
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	2
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	4
	DB	3
	DB	4
	DB	4
	DB	4
	DB	4
	DB	0
?vsprintf@@YAHPADPBDPAE@Z ENDP				; vsprintf
_TEXT	ENDS
END
