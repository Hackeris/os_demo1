; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	i:\os\10\a\krnl\krnl\ipc.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?reset_msg@@YAXPAU_tagMESSAGE@@@Z		; reset_msg
EXTRN	?memset@@YAPAXPAXDI@Z:PROC			; memset
; Function compile flags: /Ogtpy
; File i:\os\10\a\krnl\krnl\ipc.cpp
;	COMDAT ?reset_msg@@YAXPAU_tagMESSAGE@@@Z
_TEXT	SEGMENT
_msg$ = 8						; size = 4
?reset_msg@@YAXPAU_tagMESSAGE@@@Z PROC			; reset_msg, COMDAT

; 14   : 	memset(msg,0,sizeof(MESSAGE));

	mov	eax, DWORD PTR _msg$[esp-4]
	push	48					; 00000030H
	push	0
	push	eax
	call	?memset@@YAPAXPAXDI@Z			; memset
	add	esp, 12					; 0000000cH

; 15   : }

	ret	0
?reset_msg@@YAXPAU_tagMESSAGE@@@Z ENDP			; reset_msg
_TEXT	ENDS
PUBLIC	?block@@YAXPAU_tagPROC@@@Z			; block
EXTRN	?schedule@@YAXXZ:PROC				; schedule
; Function compile flags: /Ogtpy
;	COMDAT ?block@@YAXPAU_tagPROC@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?block@@YAXPAU_tagPROC@@@Z PROC				; block, COMDAT

; 19   : 	//	assert(p->p_flags);
; 20   : 	schedule();

	jmp	?schedule@@YAXXZ			; schedule
?block@@YAXPAU_tagPROC@@@Z ENDP				; block
_TEXT	ENDS
PUBLIC	?unblock@@YAXPAU_tagPROC@@@Z			; unblock
; Function compile flags: /Ogtpy
;	COMDAT ?unblock@@YAXPAU_tagPROC@@@Z
_TEXT	SEGMENT
_p$ = 8							; size = 4
?unblock@@YAXPAU_tagPROC@@@Z PROC			; unblock, COMDAT

; 25   : 	//	assert(p->p_flags == 0);
; 26   : }

	ret	0
?unblock@@YAXPAU_tagPROC@@@Z ENDP			; unblock
_TEXT	ENDS
PUBLIC	??_C@_03NBPCCBKM@?$DN_?$DN?$AA@			; `string'
PUBLIC	??_C@_04CKOMMCPL@?9?$DO?$CFs?$AA@		; `string'
PUBLIC	??_C@_05HEEPJMHH@?$DN_?$DN?$CFs?$AA@		; `string'
PUBLIC	?deadlock@@YAHHH@Z				; deadlock
EXTRN	?DbgPrintf@@YAHPBDZZ:PROC			; DbgPrintf
EXTRN	?proc_table@@3PAU_tagPROC@@A:BYTE		; proc_table
;	COMDAT ??_C@_03NBPCCBKM@?$DN_?$DN?$AA@
CONST	SEGMENT
??_C@_03NBPCCBKM@?$DN_?$DN?$AA@ DB '=_=', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04CKOMMCPL@?9?$DO?$CFs?$AA@
CONST	SEGMENT
??_C@_04CKOMMCPL@?9?$DO?$CFs?$AA@ DB '->%s', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_05HEEPJMHH@?$DN_?$DN?$CFs?$AA@
CONST	SEGMENT
??_C@_05HEEPJMHH@?$DN_?$DN?$CFs?$AA@ DB '=_=%s', 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?deadlock@@YAHHH@Z
_TEXT	SEGMENT
_src$ = 8						; size = 4
_dest$ = 12						; size = 4
?deadlock@@YAHHH@Z PROC					; deadlock, COMDAT

; 30   : {

	push	esi

; 31   : 	PROCESS* p = proc_table + dest;

	mov	esi, DWORD PTR _dest$[esp]
	imul	esi, 194				; 000000c2H
	lea	esi, DWORD PTR ?proc_table@@3PAU_tagPROC@@A[esi]
	mov	eax, esi

; 32   : 	while(1){
; 33   : 		if(p->p_flags & SENDING){

	mov	cl, 2
	test	BYTE PTR [eax+118], cl
	push	edi
	je	SHORT $LN6@deadlock
	mov	edi, DWORD PTR _src$[esp+4]
	npad	1
$LL8@deadlock:

; 34   : 			if(p->p_sendto == src){

	mov	eax, DWORD PTR [eax+130]
	cmp	eax, edi
	je	SHORT $LN13@deadlock

; 44   : 			}
; 45   : 			p = proc_table + p->p_sendto;

	imul	eax, 194				; 000000c2H
	add	eax, OFFSET ?proc_table@@3PAU_tagPROC@@A ; proc_table
	test	BYTE PTR [eax+118], cl
	jne	SHORT $LL8@deadlock
$LN6@deadlock:
	pop	edi

; 46   : 		}
; 47   : 		else{
; 48   : 			break;
; 49   : 		}
; 50   : 	}
; 51   : 	return 0;

	xor	eax, eax
	pop	esi

; 52   : }

	ret	0
$LN13@deadlock:

; 35   : 				p = proc_table + dest;
; 36   : 				DbgPrintf("=_=%s",p->p_name);

	lea	eax, DWORD PTR [esi+94]
	push	eax
	push	OFFSET ??_C@_05HEEPJMHH@?$DN_?$DN?$CFs?$AA@
	call	?DbgPrintf@@YAHPBDZZ			; DbgPrintf
	add	esp, 8
	imul	edi, 194				; 000000c2H
	lea	edi, DWORD PTR ?proc_table@@3PAU_tagPROC@@A[edi]
	npad	4
$LL4@deadlock:

; 37   : 				do{
; 38   : 					//	assert(p->p_msg);
; 39   : 					p = proc_table + p->p_sendto;

	mov	esi, DWORD PTR [esi+130]
	imul	esi, 194				; 000000c2H
	add	esi, OFFSET ?proc_table@@3PAU_tagPROC@@A ; proc_table

; 40   : 					DbgPrintf("->%s",p->p_name);

	lea	ecx, DWORD PTR [esi+94]
	push	ecx
	push	OFFSET ??_C@_04CKOMMCPL@?9?$DO?$CFs?$AA@
	call	?DbgPrintf@@YAHPBDZZ			; DbgPrintf
	add	esp, 8

; 41   : 				}while(p != proc_table+src);

	cmp	esi, edi
	jne	SHORT $LL4@deadlock

; 42   : 				DbgPrintf("=_=");

	push	OFFSET ??_C@_03NBPCCBKM@?$DN_?$DN?$AA@
	call	?DbgPrintf@@YAHPBDZZ			; DbgPrintf
	add	esp, 4
	pop	edi

; 43   : 				return 1;

	mov	eax, 1
	pop	esi

; 52   : }

	ret	0
?deadlock@@YAHHH@Z ENDP					; deadlock
_TEXT	ENDS
PUBLIC	?msg_send@@YAHPAU_tagPROC@@HPAU_tagMESSAGE@@@Z	; msg_send
EXTRN	?memcpy@@YAPAXPAXPBXI@Z:PROC			; memcpy
EXTRN	?va2la@@YAPAXHPAX@Z:PROC			; va2la
; Function compile flags: /Ogtpy
;	COMDAT ?msg_send@@YAHPAU_tagPROC@@HPAU_tagMESSAGE@@@Z
_TEXT	SEGMENT
_current$ = 8						; size = 4
_dest$ = 12						; size = 4
_m$ = 16						; size = 4
?msg_send@@YAHPAU_tagPROC@@HPAU_tagMESSAGE@@@Z PROC	; msg_send, COMDAT

; 55   : {

	push	ebx

; 56   : 	PROCESS*	sender = current;
; 57   : 	PROCESS*	p_dest = proc_table + dest;
; 58   : 
; 59   : 	//	assert(proc2pid(sender) != dest)
; 60   : 
; 61   : 	if(deadlock(proc2pid(sender),dest)){			//	check for dead lock

	mov	ebx, DWORD PTR _current$[esp]
	mov	ecx, ebx
	sub	ecx, OFFSET ?proc_table@@3PAU_tagPROC@@A ; proc_table
	mov	eax, 354224107				; 151d07ebH
	imul	ecx
	push	ebp
	mov	ebp, DWORD PTR _dest$[esp+4]
	push	esi
	mov	esi, ebp
	push	edi
	imul	esi, 194				; 000000c2H
	sar	edx, 4
	mov	edi, edx
	shr	edi, 31					; 0000001fH
	add	edi, edx
	push	ebp
	push	edi
	add	esi, OFFSET ?proc_table@@3PAU_tagPROC@@A ; proc_table
	call	?deadlock@@YAHHH@Z			; deadlock
	add	esp, 8

; 62   : 		//	dead lock
; 63   : 	}
; 64   : 	if((p_dest->p_flags & RECEIVING) && 
; 65   : 		(p_dest->p_recvfrom == proc2pid(sender)) ||
; 66   : 		(p_dest->p_recvfrom == ANY_TASK)){				//	dest is receiving the message

	test	BYTE PTR [esi+118], 4
	je	SHORT $LN6@msg_send
	cmp	DWORD PTR [esi+126], edi
	je	SHORT $LN7@msg_send
$LN6@msg_send:
	cmp	DWORD PTR [esi+126], 46			; 0000002eH
	jne	SHORT $LN8@msg_send
$LN7@msg_send:

; 67   : 			//	assert(p_dest->p_msg);
; 68   : 			//	assert(m);
; 69   : 
; 70   : 			memcpy(va2la(dest,p_dest->p_msg),
; 71   : 				va2la(proc2pid(sender),m),
; 72   : 				sizeof(MESSAGE));

	mov	eax, DWORD PTR _m$[esp+12]
	push	48					; 00000030H
	push	eax
	push	edi
	call	?va2la@@YAPAXHPAX@Z			; va2la
	mov	ecx, DWORD PTR [esi+122]
	add	esp, 8
	push	eax
	push	ecx
	push	ebp
	call	?va2la@@YAPAXHPAX@Z			; va2la
	add	esp, 8
	push	eax
	call	?memcpy@@YAPAXPAXPBXI@Z			; memcpy

; 73   : 			p_dest->p_msg = 0;
; 74   : 			p_dest->p_flags &= ~RECEIVING;

	and	DWORD PTR [esi+118], -5			; fffffffbH
	add	esp, 12					; 0000000cH
	pop	edi
	mov	DWORD PTR [esi+122], 0

; 75   : 			p_dest->p_recvfrom = NO_TASK;

	mov	DWORD PTR [esi+126], 56			; 00000038H
	pop	esi
	pop	ebp

; 97   : 
; 98   : 		//	assert(sender->p_flags == SENDING);
; 99   : 		//	assert(sender->p_msg != 0);
; 100  : 		//	assert(sender->p_recvfrom == NO_TASK);
; 101  : 		//	assert(sender->p_sendto == dest);
; 102  : 	}
; 103  : 	return 0;

	xor	eax, eax
	pop	ebx

; 104  : }

	ret	0
$LN8@msg_send:

; 76   : 			unblock(p_dest);
; 77   : 	}
; 78   : 	else{		//	dest is not waiting for the message
; 79   : 		sender->p_flags |= SENDING;
; 80   : 		//	assert(sender->p_flags == SENDING);
; 81   : 		sender->p_sendto = dest;
; 82   : 		sender->p_msg = m;

	mov	edx, DWORD PTR _m$[esp+12]
	or	DWORD PTR [ebx+118], 2
	mov	DWORD PTR [ebx+130], ebp
	mov	DWORD PTR [ebx+122], edx

; 83   : 
; 84   : 		PROCESS* p;
; 85   : 		if(p_dest->q_sending){

	mov	eax, DWORD PTR [esi+138]
	test	eax, eax
	je	SHORT $LN4@msg_send

; 86   : 			p = p_dest->q_sending;
; 87   : 			while(p->next_sending){

	cmp	DWORD PTR [eax+142], 0
	je	SHORT $LN2@msg_send
	npad	14
$LL3@msg_send:

; 88   : 				p = p->next_sending;

	mov	eax, DWORD PTR [eax+142]
	cmp	DWORD PTR [eax+142], 0
	jne	SHORT $LL3@msg_send
$LN2@msg_send:

; 89   : 			}
; 90   : 			p->next_sending = sender;

	mov	DWORD PTR [eax+142], ebx

; 91   : 		}
; 92   : 		else{

	jmp	SHORT $LN1@msg_send
$LN4@msg_send:

; 93   : 			p_dest->q_sending = sender;

	mov	DWORD PTR [esi+138], ebx
$LN1@msg_send:

; 94   : 		}
; 95   : 		sender->next_sending = 0;

	mov	DWORD PTR [ebx+142], 0

; 96   : 		block(sender);

	call	?schedule@@YAXXZ			; schedule
	pop	edi
	pop	esi
	pop	ebp

; 97   : 
; 98   : 		//	assert(sender->p_flags == SENDING);
; 99   : 		//	assert(sender->p_msg != 0);
; 100  : 		//	assert(sender->p_recvfrom == NO_TASK);
; 101  : 		//	assert(sender->p_sendto == dest);
; 102  : 	}
; 103  : 	return 0;

	xor	eax, eax
	pop	ebx

; 104  : }

	ret	0
?msg_send@@YAHPAU_tagPROC@@HPAU_tagMESSAGE@@@Z ENDP	; msg_send
_TEXT	ENDS
PUBLIC	?msg_receive@@YAHPAU_tagPROC@@HPAU_tagMESSAGE@@@Z ; msg_receive
; Function compile flags: /Ogtpy
;	COMDAT ?msg_receive@@YAHPAU_tagPROC@@HPAU_tagMESSAGE@@@Z
_TEXT	SEGMENT
_prev$ = -52						; size = 4
_msg$3210 = -48						; size = 48
_current$ = 8						; size = 4
_src$ = 12						; size = 4
_m$ = 16						; size = 4
?msg_receive@@YAHPAU_tagPROC@@HPAU_tagMESSAGE@@@Z PROC	; msg_receive, COMDAT

; 107  : {

	sub	esp, 52					; 00000034H
	push	ebx
	push	ebp

; 108  : 	PROCESS*	p_who_wanna_recv = current;
; 109  : 	PROCESS*	p_from = 0;
; 110  : 	PROCESS*	prev = 0;
; 111  : 	int copyok = 0;
; 112  : 
; 113  : 	//	assert(proc2pid(p_who_wanna_recv) != src);
; 114  : 	if( (p_who_wanna_recv->has_int_msg) &&
; 115  : 		((src == ANY_TASK) || (src == INTERRUPT)))

	mov	ebp, DWORD PTR _src$[esp+56]
	push	esi
	push	edi
	mov	edi, DWORD PTR _current$[esp+64]
	xor	ebx, ebx
	xor	esi, esi
	cmp	DWORD PTR [edi+134], ebx
	mov	DWORD PTR _prev$[esp+68], ebx
	je	SHORT $LN30@msg_receiv
	cmp	ebp, 46					; 0000002eH
	je	SHORT $LN14@msg_receiv
	cmp	ebp, -10				; fffffff6H
	jne	SHORT $LN30@msg_receiv
$LN14@msg_receiv:

; 116  : 	{
; 117  : 		//	there is an interrupt needs p_who_wanna_recv's handling
; 118  : 		//	and p_who_wanna_recv is ready to handle it
; 119  : 		MESSAGE msg;
; 120  : 		reset_msg(&msg);

	push	48					; 00000030H
	lea	eax, DWORD PTR _msg$3210[esp+72]
	push	ebx
	push	eax
	call	?memset@@YAPAXPAXDI@Z			; memset

; 121  : 		msg.source = INTERRUPT;
; 122  : 		msg.type = HARD_INT;
; 123  : 		//	assert(m);
; 124  : 		memcpy(va2la(proc2pid(p_who_wanna_recv),m),&msg,sizeof(MESSAGE));

	mov	edx, DWORD PTR _m$[esp+76]
	add	esp, 12					; 0000000cH
	push	48					; 00000030H
	lea	ecx, DWORD PTR _msg$3210[esp+72]
	push	ecx
	push	edx
	mov	ecx, edi
	sub	ecx, OFFSET ?proc_table@@3PAU_tagPROC@@A ; proc_table
	mov	eax, 354224107				; 151d07ebH
	imul	ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	push	eax
	mov	DWORD PTR _msg$3210[esp+84], -10	; fffffff6H
	mov	DWORD PTR _msg$3210[esp+88], 1
	call	?va2la@@YAPAXHPAX@Z			; va2la
	add	esp, 8
	push	eax
	call	?memcpy@@YAPAXPAXPBXI@Z			; memcpy
	add	esp, 12					; 0000000cH

; 125  : 		p_who_wanna_recv->has_int_msg =0;

	mov	DWORD PTR [edi+134], ebx
	pop	edi
	pop	esi
	pop	ebp

; 229  : 
; 230  : 		//	assert(p_who_wanna_recv->p_flags == RECEIVING);
; 231  : 		//	assert(p_who_wanna_recv->p_msg != 0);
; 232  : 		//	assert(p_who_wanna_recv->p_recvfrom != NO_TASK);
; 233  : 		//	assert(p_who_wanna_recv->p_sendto == NO_TASK);
; 234  : 		//	assert(p_who_wanna_recv->has_int_msg == 0);
; 235  : 	}
; 236  : 	return 0;

	xor	eax, eax
	pop	ebx

; 237  : }

	add	esp, 52					; 00000034H
	ret	0
$LN30@msg_receiv:

; 126  : 
; 127  : 		//	assert(p_who_wanna_recv->p_flags == 0);
; 128  : 		//	assert(p_who_wanna_recv->p_msg ==0);
; 129  : 		//	assert(p_who_wanna_recv->p_sendto == NO_TASK);
; 130  : 		//	assert(p_who_wanna_recv->has_int_msg ==0);
; 131  : 
; 132  : 		return 0;
; 133  : 	}
; 134  : 
; 135  : 	if(src == ANY_TASK){

	cmp	ebp, 46					; 0000002eH
	jne	SHORT $LN13@msg_receiv

; 136  : 		//	p_who_wanna_recv is ready to receive message from 
; 137  : 		//	ANY_TASK proc,we'll check the sending queue and pick the first
; 138  : 		//	proc in it
; 139  : 		if(p_who_wanna_recv->q_sending){

	mov	eax, DWORD PTR [edi+138]
	cmp	eax, ebx
	je	$LN28@msg_receiv

; 140  : 			p_from = p_who_wanna_recv->q_sending;

	mov	esi, eax

; 141  : 			copyok = 1;
; 142  : 
; 143  : 			//	assert(p_who_wanna_recv->p_flags == 0);
; 144  : 			//	assert(p_who_wanna_recv->p_msg == 0);
; 145  : 			//	assert(p_who_wanna_recv->p_recvfrom == 0);
; 146  : 			//	assert(p_who_wanna_recv->p_sendto == 0);
; 147  : 			//	assert(p_who_wanna_recv->q_sending != 0);
; 148  : 			//	assert(p_from->p_flags == SENDING);
; 149  : 			//	assert(p_from->p_msg != 0);
; 150  : 			//	assert(p_from->p_recvfrom == NO_TASK);
; 151  : 			//	assert(p_from->p_sendto == proc2pid(p_who_wanna_recv));
; 152  : 		}
; 153  : 	}
; 154  : 	else{

	jmp	SHORT $LN27@msg_receiv
$LN13@msg_receiv:

; 155  : 		//	p_who_wanna_recv wants to receive a message from
; 156  : 		//	a certain proc: src
; 157  : 		p_from = &proc_table[src];

	mov	esi, ebp
	imul	esi, 194				; 000000c2H
	add	esi, OFFSET ?proc_table@@3PAU_tagPROC@@A ; proc_table

; 158  : 		if((p_from->p_flags & SENDING) &&
; 159  : 			(p_from->p_sendto == proc2pid(p_who_wanna_recv))){

	test	BYTE PTR [esi+118], 2
	je	$LN28@msg_receiv
	mov	ecx, edi
	sub	ecx, OFFSET ?proc_table@@3PAU_tagPROC@@A ; proc_table
	mov	eax, 354224107				; 151d07ebH
	imul	ecx
	sar	edx, 4
	mov	ecx, edx
	shr	ecx, 31					; 0000001fH
	add	ecx, edx
	cmp	DWORD PTR [esi+130], ecx
	jne	$LN28@msg_receiv

; 160  : 			//	perfect,src is sending a message to p_who_wanna_recv
; 161  : 			copyok = 1;
; 162  : 			
; 163  : 			PROCESS* p = p_who_wanna_recv;

	mov	ebx, edi
	npad	10
$LL9@msg_receiv:

; 164  : 			//	assert(p);
; 165  : 
; 166  : 			while(p){
; 167  : 				//	assert(p_from->p_flags & SENDING);
; 168  : 				if(proc2pid(p) == src){

	mov	ecx, ebx
	sub	ecx, OFFSET ?proc_table@@3PAU_tagPROC@@A ; proc_table
	mov	eax, 354224107				; 151d07ebH
	imul	ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, ebp
	je	SHORT $LN25@msg_receiv

; 170  : 					break;
; 171  : 				}
; 172  : 				prev = p;

	mov	DWORD PTR _prev$[esp+68], ebx

; 173  : 				p = p->next_sending;

	mov	ebx, DWORD PTR [ebx+142]
	test	ebx, ebx
	jne	SHORT $LL9@msg_receiv

; 164  : 			//	assert(p);
; 165  : 
; 166  : 			while(p){
; 167  : 				//	assert(p_from->p_flags & SENDING);
; 168  : 				if(proc2pid(p) == src){

	jmp	SHORT $LN32@msg_receiv
$LN25@msg_receiv:

; 169  : 					p_from = p;

	mov	esi, ebx
$LN32@msg_receiv:
	xor	ebx, ebx
$LN27@msg_receiv:

; 174  : 			}
; 175  : 			//	assert(p_who_wanna_recv->p_flags ==0);
; 176  : 			//	assert(p_who_wanna_recv->p_msg ==0);
; 177  : 			//	assert(p_who_wanna_recv->p_sendto == NO_TASK);
; 178  : 			//	assert(p_who_wanna_recv->p_recvfrom == NO_TASK);
; 179  : 			//	assert(p_who_wanna_recv->q_sending != 0);
; 180  : 			//	assert(p_from->p_flags == SENDING);
; 181  : 			//	assert(p_from->p_msg != 0);
; 182  : 			//	assert(p_from->p_recvfrom == NO_TASK);
; 183  : 			//	assert(p_from->sendto == proc2pid(p_who_wanna_recv));
; 184  : 		}
; 185  : 	}
; 186  : 	if(copyok){
; 187  : 		//	it's determined from which proc the message whill 
; 188  : 		//	be copied. Note htat this proc must have been 
; 189  : 		//	waiting for the moment in the queue, so we should
; 190  : 		//	remove it from the queue
; 191  : 		if(p_from == p_who_wanna_recv->q_sending){

	cmp	esi, DWORD PTR [edi+138]
	jne	SHORT $LN5@msg_receiv

; 192  : 			//	assert(prev == 0);
; 193  : 			p_who_wanna_recv->q_sending = p_from->next_sending;

	mov	ecx, DWORD PTR [esi+142]
	mov	DWORD PTR [edi+138], ecx

; 194  : 			p_from->next_sending = 0;
; 195  : 		}
; 196  : 		else{

	jmp	SHORT $LN33@msg_receiv
$LN5@msg_receiv:

; 197  : 			//	assert(prev);
; 198  : 			prev->next_sending = p_from->next_sending;

	mov	edx, DWORD PTR [esi+142]
	mov	eax, DWORD PTR _prev$[esp+68]
	mov	DWORD PTR [eax+142], edx
$LN33@msg_receiv:

; 199  : 			p_from->next_sending = 0;
; 200  : 		}
; 201  : 
; 202  : 		//	assert(m);
; 203  : 		//	assert(p_from->p_msg);
; 204  : 		//	copy the message
; 205  : 		memcpy(va2la(proc2pid(p_who_wanna_recv),m),
; 206  : 			va2la(proc2pid(p_from),p_from->p_msg),
; 207  : 			sizeof(MESSAGE));

	mov	ecx, DWORD PTR [esi+122]
	push	48					; 00000030H
	push	ecx
	mov	ecx, esi
	sub	ecx, OFFSET ?proc_table@@3PAU_tagPROC@@A ; proc_table
	mov	eax, 354224107				; 151d07ebH
	imul	ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	push	eax
	mov	DWORD PTR [esi+142], ebx
	call	?va2la@@YAPAXHPAX@Z			; va2la
	mov	ecx, DWORD PTR _m$[esp+76]
	add	esp, 8
	push	eax
	sub	edi, OFFSET ?proc_table@@3PAU_tagPROC@@A ; proc_table
	mov	eax, 354224107				; 151d07ebH
	imul	edi
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	push	ecx
	add	eax, edx
	push	eax
	call	?va2la@@YAPAXHPAX@Z			; va2la
	add	esp, 8
	push	eax
	call	?memcpy@@YAPAXPAXPBXI@Z			; memcpy

; 208  : 		p_from->p_msg = 0;
; 209  : 		p_from->p_sendto = NO_TASK;
; 210  : 		p_from->p_flags &= ~SENDING;

	and	DWORD PTR [esi+118], -3			; fffffffdH
	add	esp, 12					; 0000000cH
	pop	edi
	mov	DWORD PTR [esi+122], ebx
	mov	DWORD PTR [esi+130], 56			; 00000038H
	pop	esi
	pop	ebp

; 229  : 
; 230  : 		//	assert(p_who_wanna_recv->p_flags == RECEIVING);
; 231  : 		//	assert(p_who_wanna_recv->p_msg != 0);
; 232  : 		//	assert(p_who_wanna_recv->p_recvfrom != NO_TASK);
; 233  : 		//	assert(p_who_wanna_recv->p_sendto == NO_TASK);
; 234  : 		//	assert(p_who_wanna_recv->has_int_msg == 0);
; 235  : 	}
; 236  : 	return 0;

	xor	eax, eax
	pop	ebx

; 237  : }

	add	esp, 52					; 00000034H
	ret	0
$LN28@msg_receiv:

; 211  : 		unblock(p_from);
; 212  : 	}
; 213  : 	else{
; 214  : 		//	nobody's sending msg
; 215  : 		//	set flags so that p_who_wanna_recv will not
; 216  : 		//	be scheduled until it is unblocked
; 217  : 
; 218  : 		p_who_wanna_recv->p_flags |= RECEIVING;

	or	DWORD PTR [edi+118], 4

; 219  : 		p_who_wanna_recv->p_msg = m;
; 220  : 
; 221  : 		if(src == ANY_TASK){

	cmp	ebp, 46					; 0000002eH
	mov	ecx, DWORD PTR _m$[esp+64]
	mov	DWORD PTR [edi+122], ecx
	jne	SHORT $LN2@msg_receiv

; 222  : 			p_who_wanna_recv->p_recvfrom = ANY_TASK;

	mov	DWORD PTR [edi+126], ebp

; 226  : 		}
; 227  : 
; 228  : 		block(p_who_wanna_recv);

	call	?schedule@@YAXXZ			; schedule
	pop	edi
	pop	esi
	pop	ebp

; 229  : 
; 230  : 		//	assert(p_who_wanna_recv->p_flags == RECEIVING);
; 231  : 		//	assert(p_who_wanna_recv->p_msg != 0);
; 232  : 		//	assert(p_who_wanna_recv->p_recvfrom != NO_TASK);
; 233  : 		//	assert(p_who_wanna_recv->p_sendto == NO_TASK);
; 234  : 		//	assert(p_who_wanna_recv->has_int_msg == 0);
; 235  : 	}
; 236  : 	return 0;

	xor	eax, eax
	pop	ebx

; 237  : }

	add	esp, 52					; 00000034H
	ret	0
$LN2@msg_receiv:

; 223  : 		}
; 224  : 		else{
; 225  : 			p_who_wanna_recv->p_recvfrom = proc2pid(p_from);

	sub	esi, OFFSET ?proc_table@@3PAU_tagPROC@@A ; proc_table
	mov	eax, 354224107				; 151d07ebH
	imul	esi
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	mov	DWORD PTR [edi+126], eax

; 226  : 		}
; 227  : 
; 228  : 		block(p_who_wanna_recv);

	call	?schedule@@YAXXZ			; schedule
	pop	edi
	pop	esi
	pop	ebp

; 229  : 
; 230  : 		//	assert(p_who_wanna_recv->p_flags == RECEIVING);
; 231  : 		//	assert(p_who_wanna_recv->p_msg != 0);
; 232  : 		//	assert(p_who_wanna_recv->p_recvfrom != NO_TASK);
; 233  : 		//	assert(p_who_wanna_recv->p_sendto == NO_TASK);
; 234  : 		//	assert(p_who_wanna_recv->has_int_msg == 0);
; 235  : 	}
; 236  : 	return 0;

	xor	eax, eax
	pop	ebx

; 237  : }

	add	esp, 52					; 00000034H
	ret	0
?msg_receive@@YAHPAU_tagPROC@@HPAU_tagMESSAGE@@@Z ENDP	; msg_receive
_TEXT	ENDS
PUBLIC	?inform_int@@YAXH@Z				; inform_int
; Function compile flags: /Ogtpy
;	COMDAT ?inform_int@@YAXH@Z
_TEXT	SEGMENT
_task_nr$ = 8						; size = 4
?inform_int@@YAXH@Z PROC				; inform_int, COMDAT

; 241  : 	PROCESS* p = proc_table + task_nr;

	mov	eax, DWORD PTR _task_nr$[esp-4]
	imul	eax, 194				; 000000c2H
	add	eax, OFFSET ?proc_table@@3PAU_tagPROC@@A ; proc_table

; 242  : 
; 243  : 	if ((p->p_flags & RECEIVING) && /* dest is waiting for the msg */
; 244  : 	    ((p->p_recvfrom == INTERRUPT) || (p->p_recvfrom == ANY_TASK))) {

	test	BYTE PTR [eax+118], 4
	je	SHORT $LN3@inform_int
	mov	ecx, DWORD PTR [eax+126]
	cmp	ecx, -10				; fffffff6H
	je	SHORT $LN2@inform_int
	cmp	ecx, 46					; 0000002eH
	jne	SHORT $LN3@inform_int
$LN2@inform_int:

; 245  : 		p->p_msg->source = INTERRUPT;

	mov	ecx, DWORD PTR [eax+122]
	mov	DWORD PTR [ecx], -10			; fffffff6H

; 246  : 		p->p_msg->type = HARD_INT;

	mov	edx, DWORD PTR [eax+122]
	mov	DWORD PTR [edx+4], 1

; 247  : 		p->p_msg = 0;

	xor	ecx, ecx

; 248  : 		p->has_int_msg = 0;
; 249  : 		p->p_flags &= ~RECEIVING; /* dest has received the msg */

	and	DWORD PTR [eax+118], -5			; fffffffbH
	mov	DWORD PTR [eax+122], ecx
	mov	DWORD PTR [eax+134], ecx

; 250  : 		p->p_recvfrom = NO_TASK;

	mov	DWORD PTR [eax+126], 56			; 00000038H

; 261  : 	}
; 262  : }

	ret	0
$LN3@inform_int:

; 251  : 		//assert(p->p_flags == 0);
; 252  : 		unblock(p);
; 253  : 
; 254  : 		//assert(p->p_flags == 0);
; 255  : 		//assert(p->p_msg == 0);
; 256  : 		//assert(p->p_recvfrom == NO_TASK);
; 257  : 		//assert(p->p_sendto == NO_TASK);
; 258  : 	}
; 259  : 	else {
; 260  : 		p->has_int_msg = 1;

	mov	DWORD PTR [eax+134], 1

; 261  : 	}
; 262  : }

	ret	0
?inform_int@@YAXH@Z ENDP				; inform_int
_TEXT	ENDS
END
