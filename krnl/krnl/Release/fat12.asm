; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	i:\os\10\a\krnl\krnl\fat12.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?_fs_fat@@3U_FILE_SYS@@A			; _fs_fat
PUBLIC	?FAT@@3PAEA					; FAT
PUBLIC	?_mnt_info@@3U_MOUNT_INFO@@A			; _mnt_info
_BSS	SEGMENT
?_fs_fat@@3U_FILE_SYS@@A DB 01cH DUP (?)		; _fs_fat
?FAT@@3PAEA DB	0400H DUP (?)				; FAT
?_mnt_info@@3U_MOUNT_INFO@@A DB 01cH DUP (?)		; _mnt_info
_BSS	ENDS
PUBLIC	?to_dos_filename@@YAXPBDPADI@Z			; to_dos_filename
EXTRN	?strlen@@YAIPBD@Z:PROC				; strlen
EXTRN	?memset@@YAPAXPAXDI@Z:PROC			; memset
; Function compile flags: /Ogtpy
; File i:\os\10\a\krnl\krnl\fat12.cpp
;	COMDAT ?to_dos_filename@@YAXPBDPADI@Z
_TEXT	SEGMENT
_filename$ = 8						; size = 4
_fname$ = 12						; size = 4
_len$ = 16						; size = 4
?to_dos_filename@@YAXPBDPADI@Z PROC			; to_dos_filename, COMDAT

; 18   : 	uint32_t	i = 0;
; 19   : 
; 20   : 	if(len > 11){

	mov	eax, DWORD PTR _len$[esp-4]
	cmp	eax, 11					; 0000000bH
	ja	$LN31@to_dos_fil
	push	ebx

; 21   : 		return;
; 22   : 	}
; 23   : 	if(!fname || !filename){

	mov	ebx, DWORD PTR _fname$[esp]
	test	ebx, ebx
	je	$LN35@to_dos_fil
	push	edi
	mov	edi, DWORD PTR _filename$[esp+4]
	test	edi, edi
	je	$LN36@to_dos_fil
	push	esi

; 24   : 		return ;
; 25   : 	}
; 26   : 
; 27   : 	memset(fname,' ',len);

	push	eax
	push	32					; 00000020H
	push	ebx
	call	?memset@@YAPAXPAXDI@Z			; memset

; 28   : 
; 29   : 	//	8.3
; 30   : 	for(i = 0; i < strlen(filename)-1 && i < len ; i++){

	push	edi
	xor	esi, esi
	call	?strlen@@YAIPBD@Z			; strlen
	add	esp, 16					; 00000010H
	sub	eax, 1
	je	SHORT $LN22@to_dos_fil
	push	ebp
	mov	ebp, ebx
	sub	ebp, edi
$LL34@to_dos_fil:
	cmp	esi, DWORD PTR _len$[esp+12]
	jae	SHORT $LN37@to_dos_fil

; 31   : 		if(filename[i] == '.' || i == 8){

	mov	al, BYTE PTR [esi+edi]
	cmp	al, 46					; 0000002eH
	lea	ecx, DWORD PTR [esi+edi]
	je	SHORT $LN37@to_dos_fil
	cmp	esi, 8
	je	SHORT $LN37@to_dos_fil

; 32   : 			break;
; 33   : 		}
; 34   : 		fname[i] = filename[i] & ~(1 << 5);

	and	al, -33					; ffffffdfH
	push	edi
	mov	BYTE PTR [ecx+ebp], al
	add	esi, 1
	call	?strlen@@YAIPBD@Z			; strlen
	sub	eax, 1
	add	esp, 4
	cmp	esi, eax
	jb	SHORT $LL34@to_dos_fil
$LN37@to_dos_fil:
	pop	ebp
$LN22@to_dos_fil:

; 35   : 	}
; 36   : 	// add extension if needed
; 37   : 	if (filename[i]=='.') {

	cmp	BYTE PTR [esi+edi], 46			; 0000002eH
	jne	SHORT $LN30@to_dos_fil

; 38   : 
; 39   : 		// note: cant just copy over-extension might not be 3 chars
; 40   : 		for (int k=0; k<3; k++) {
; 41   : 
; 42   : 			++i;
; 43   : 			if ( filename[i] )

	mov	al, BYTE PTR [esi+edi+1]
	test	al, al
	je	SHORT $LN6@to_dos_fil

; 44   : 				fname[8+k] = filename[i];

	mov	BYTE PTR [ebx+8], al
$LN6@to_dos_fil:

; 38   : 
; 39   : 		// note: cant just copy over-extension might not be 3 chars
; 40   : 		for (int k=0; k<3; k++) {
; 41   : 
; 42   : 			++i;
; 43   : 			if ( filename[i] )

	mov	al, BYTE PTR [esi+edi+2]
	test	al, al
	je	SHORT $LN28@to_dos_fil

; 44   : 				fname[8+k] = filename[i];

	mov	BYTE PTR [ebx+9], al
$LN28@to_dos_fil:

; 38   : 
; 39   : 		// note: cant just copy over-extension might not be 3 chars
; 40   : 		for (int k=0; k<3; k++) {
; 41   : 
; 42   : 			++i;
; 43   : 			if ( filename[i] )

	mov	al, BYTE PTR [esi+edi+3]
	test	al, al
	je	SHORT $LN30@to_dos_fil

; 44   : 				fname[8+k] = filename[i];

	mov	BYTE PTR [ebx+10], al
$LN30@to_dos_fil:

; 45   : 		}
; 46   : 	}
; 47   : 	// extension must be uppercase (we dont handle LFNs)
; 48   : 	for (i = 0; i < 3; i++)
; 49   : 		fname[8+i] = (fname[8+i]) & ~(1 << 5);

	and	BYTE PTR [ebx+8], -33			; ffffffdfH
	and	BYTE PTR [ebx+9], -33			; ffffffdfH
	and	BYTE PTR [ebx+10], -33			; ffffffdfH
	pop	esi
$LN36@to_dos_fil:
	pop	edi
$LN35@to_dos_fil:
	pop	ebx
$LN31@to_dos_fil:

; 50   : }

	ret	0
?to_dos_filename@@YAXPBDPADI@Z ENDP			; to_dos_filename
_TEXT	ENDS
PUBLIC	?fsys_fat_directory@@YA?AU_FILE@@PBD@Z		; fsys_fat_directory
EXTRN	?strcpy@@YAPADPADPBD@Z:PROC			; strcpy
EXTRN	?strcmp@@YAHPBD0@Z:PROC				; strcmp
EXTRN	?memcpy@@YAPAXPAXPBXI@Z:PROC			; memcpy
EXTRN	?flpy_do_read_sector@@YAPAEH@Z:PROC		; flpy_do_read_sector
; Function compile flags: /Ogtpy
;	COMDAT ?fsys_fat_directory@@YA?AU_FILE@@PBD@Z
_TEXT	SEGMENT
_name$3136 = -24					; size = 11
_dos_name$ = -12					; size = 11
$T3259 = 8						; size = 4
_dir_name$ = 12						; size = 4
?fsys_fat_directory@@YA?AU_FILE@@PBD@Z PROC		; fsys_fat_directory, COMDAT

; 53   : {

	sub	esp, 24					; 00000018H

; 54   : 	FILE file;
; 55   : 	unsigned char* buf;
; 56   : 	DIRECTORY*	directory;
; 57   : 
; 58   : 	//	get 8.3 dir name
; 59   : 	char dos_name[11];
; 60   : 	to_dos_filename(dir_name,dos_name,11);

	mov	ecx, DWORD PTR _dir_name$[esp+20]
	push	ebx
	push	ebp
	push	esi
	push	edi
	push	11					; 0000000bH
	lea	eax, DWORD PTR _dos_name$[esp+44]
	push	eax
	push	ecx
	call	?to_dos_filename@@YAXPBDPADI@Z		; to_dos_filename

; 61   : 	dos_name[11]=0;

	xor	ebx, ebx
	add	esp, 12					; 0000000cH
	mov	BYTE PTR _dos_name$[esp+51], bl

; 62   : 
; 63   : 	//	14 sectors per dir
; 64   : 	for(int sector = 0;sector < 14; sector++){

	xor	ebp, ebp
$LL9@fsys_fat_d:

; 65   : 		//	read in sector of root directory
; 66   : 		buf = (unsigned char* )flpy_do_read_sector(_mnt_info.rootOffset + sector);

	mov	edx, DWORD PTR ?_mnt_info@@3U_MOUNT_INFO@@A+12
	add	edx, ebp
	push	edx
	call	?flpy_do_read_sector@@YAPAEH@Z		; flpy_do_read_sector
	add	esp, 4

; 67   : 
; 68   : 		//DbgPrintf("%d  ",_mnt_info.rootOffset + sector);
; 69   : 
; 70   : 		//	get directory info
; 71   : 		directory = (DIRECTORY*)buf;

	mov	esi, eax

; 72   : 
; 73   : 		//	16 entries per sector
; 74   : 		for(int i = 0; i< 16 ; i++){

	xor	edi, edi
$LL6@fsys_fat_d:

; 75   : 			char name[11];
; 76   : 			memcpy(name,directory->Filename,11);

	push	11					; 0000000bH
	lea	eax, DWORD PTR _name$3136[esp+44]
	push	esi
	push	eax
	call	?memcpy@@YAPAXPAXPBXI@Z			; memcpy

; 77   : 			name[11] = 0;
; 78   : 
; 79   : 			//	find a match?
; 80   : 			if(strcmp(dos_name,name) == 0){

	lea	ecx, DWORD PTR _name$3136[esp+52]
	push	ecx
	lea	edx, DWORD PTR _dos_name$[esp+56]
	push	edx
	mov	BYTE PTR _name$3136[esp+71], bl
	call	?strcmp@@YAHPBD0@Z			; strcmp
	add	esp, 20					; 00000014H
	test	eax, eax
	je	SHORT $LN14@fsys_fat_d
	add	edi, 1

; 95   : 			}
; 96   : 			directory ++;

	add	esi, 32					; 00000020H
	cmp	edi, 16					; 00000010H
	jl	SHORT $LL6@fsys_fat_d
	add	ebp, 1
	cmp	ebp, 14					; 0000000eH
	jl	SHORT $LL9@fsys_fat_d

; 97   : 		}
; 98   : 	}
; 99   : 	file.flags = FS_INVALID;

	mov	eax, DWORD PTR $T3259[esp+36]
	pop	edi
	pop	esi
	pop	ebp
	mov	DWORD PTR [eax+32], 2
	pop	ebx

; 100  : 	return file;
; 101  : }

	add	esp, 24					; 00000018H
	ret	0
$LN14@fsys_fat_d:

; 81   : 				strcpy(file.name,dir_name);

	mov	eax, DWORD PTR _dir_name$[esp+36]
	mov	edi, DWORD PTR $T3259[esp+36]
	push	eax
	push	edi
	call	?strcpy@@YAPADPADPBD@Z			; strcpy

; 82   : 				file.id = 0;

	mov	DWORD PTR [edi+40], ebx

; 83   : 				file.current_cluster = directory->FirstCluster;

	movzx	ecx, WORD PTR [esi+26]
	mov	DWORD PTR [edi+52], ecx

; 84   : 				file.file_len = directory->FileSize;

	mov	edx, DWORD PTR [esi+28]
	add	esp, 8

; 85   : 				file.eof = 0;
; 86   : 				
; 87   : 				if(directory->Attrib == 0x10){

	xor	eax, eax
	mov	DWORD PTR [edi+44], ebx
	mov	DWORD PTR [edi+36], edx
	cmp	BYTE PTR [esi+11], 16			; 00000010H
	sete	al
	mov	DWORD PTR [edi+32], eax

; 88   : 					file.flags = FS_DIRECTORY;
; 89   : 				}
; 90   : 				else{
; 91   : 					file.flags = FS_FILE;
; 92   : 				}
; 93   : 
; 94   : 				return file;

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	pop	ebx

; 100  : 	return file;
; 101  : }

	add	esp, 24					; 00000018H
	ret	0
?fsys_fat_directory@@YA?AU_FILE@@PBD@Z ENDP		; fsys_fat_directory
_TEXT	ENDS
PUBLIC	?fsys_fat_read@@YAXPAU_FILE@@PAEI@Z		; fsys_fat_read
; Function compile flags: /Ogtpy
;	COMDAT ?fsys_fat_read@@YAXPAU_FILE@@PAEI@Z
_TEXT	SEGMENT
_file$ = 8						; size = 4
_buffer$ = 12						; size = 4
_len$ = 16						; size = 4
?fsys_fat_read@@YAXPAU_FILE@@PAEI@Z PROC		; fsys_fat_read, COMDAT

; 104  : {

	push	ebp

; 105  : 	if(file){

	mov	ebp, DWORD PTR _file$[esp]
	test	ebp, ebp
	je	$LN4@fsys_fat_r

; 106  : 		unsigned int phys_sector = 32 + (file->current_cluster - 1);

	mov	eax, DWORD PTR [ebp+52]
	push	esi
	add	eax, 31					; 0000001fH
	push	edi

; 107  : 
; 108  : 		unsigned char* sector = (unsigned char*)flpy_do_read_sector(phys_sector);

	push	eax
	call	?flpy_do_read_sector@@YAPAEH@Z		; flpy_do_read_sector

; 109  : 		memcpy(buffer,sector,512);

	push	512					; 00000200H
	push	eax
	mov	eax, DWORD PTR _buffer$[esp+20]
	push	eax
	call	?memcpy@@YAPAXPAXPBXI@Z			; memcpy

; 110  : 
; 111  : 		//	locate FAT sector
; 112  : 		unsigned int FAT_Offset = file->current_cluster + (file->current_cluster / 2);

	mov	eax, DWORD PTR [ebp+52]
	mov	esi, eax
	shr	esi, 1
	add	esi, eax

; 113  : 		unsigned int FAT_Sector = 1 + (FAT_Offset / SECTOR_SIZE);

	mov	edi, esi
	shr	edi, 9
	add	edi, 1

; 114  : 		unsigned int enrtyOffset = FAT_Offset % SECTOR_SIZE;
; 115  : 
; 116  : 		//	read 1st FAT sector 
; 117  : 		sector = (unsigned char*)flpy_do_read_sector(FAT_Sector);

	push	edi
	call	?flpy_do_read_sector@@YAPAEH@Z		; flpy_do_read_sector

; 118  : 		memcpy(FAT,sector,512);

	push	512					; 00000200H
	push	eax
	push	OFFSET ?FAT@@3PAEA			; FAT
	call	?memcpy@@YAPAXPAXPBXI@Z			; memcpy

; 119  : 
; 120  : 		sector = (unsigned char*)flpy_do_read_sector(FAT_Sector + 1);

	add	edi, 1
	push	edi
	call	?flpy_do_read_sector@@YAPAEH@Z		; flpy_do_read_sector

; 121  : 		memcpy(FAT + 512,sector,512);

	push	512					; 00000200H
	push	eax
	push	OFFSET ?FAT@@3PAEA+512
	call	?memcpy@@YAPAXPAXPBXI@Z			; memcpy
	add	esp, 48					; 00000030H
	and	esi, 511				; 000001ffH

; 122  : 
; 123  : 		uint16_t nextCluster = *(uint16_t*)&FAT[enrtyOffset];
; 124  : 
; 125  : 		//	test if entry is ODD or EVEN
; 126  : 		if(file->current_cluster & 0x0001){

	test	BYTE PTR [ebp+52], 1
	movzx	eax, WORD PTR ?FAT@@3PAEA[esi]
	pop	edi
	pop	esi
	jne	SHORT $LN2@fsys_fat_r

; 127  : 			nextCluster >> 4;
; 128  : 		}
; 129  : 		else{
; 130  : 			nextCluster &= 0x0fff;

	and	eax, 4095				; 00000fffH
$LN2@fsys_fat_r:

; 131  : 		}
; 132  : 
; 133  : 		//	test for end of file
; 134  : 		if(nextCluster >= 0xff8){

	cmp	ax, 4088				; 00000ff8H
	jb	SHORT $LN1@fsys_fat_r

; 135  : 			file->eof = 1;

	mov	DWORD PTR [ebp+44], 1
	pop	ebp

; 141  : 	}
; 142  : }

	ret	0
$LN1@fsys_fat_r:

; 136  : 			return ;
; 137  : 		}
; 138  : 
; 139  : 		//	set next cluster
; 140  : 		file->current_cluster = nextCluster;

	movzx	ecx, ax
	mov	DWORD PTR [ebp+52], ecx
$LN4@fsys_fat_r:
	pop	ebp

; 141  : 	}
; 142  : }

	ret	0
?fsys_fat_read@@YAXPAU_FILE@@PAEI@Z ENDP		; fsys_fat_read
_TEXT	ENDS
PUBLIC	?fsys_fat_close@@YAXPAU_FILE@@@Z		; fsys_fat_close
; Function compile flags: /Ogtpy
;	COMDAT ?fsys_fat_close@@YAXPAU_FILE@@@Z
_TEXT	SEGMENT
_file$ = 8						; size = 4
?fsys_fat_close@@YAXPAU_FILE@@@Z PROC			; fsys_fat_close, COMDAT

; 146  : 	if(file)

	mov	eax, DWORD PTR _file$[esp-4]
	test	eax, eax
	je	SHORT $LN1@fsys_fat_c

; 147  : 		file->flags = FS_INVALID;

	mov	DWORD PTR [eax+32], 2
$LN1@fsys_fat_c:

; 148  : }

	ret	0
?fsys_fat_close@@YAXPAU_FILE@@@Z ENDP			; fsys_fat_close
_TEXT	ENDS
PUBLIC	?fsys_fat_open_subdir@@YA?AU_FILE@@U1@PBD@Z	; fsys_fat_open_subdir
; Function compile flags: /Ogtpy
;	COMDAT ?fsys_fat_open_subdir@@YA?AU_FILE@@U1@PBD@Z
_TEXT	SEGMENT
_name$3180 = -536					; size = 11
_dos_name$ = -524					; size = 11
_buf$3173 = -512					; size = 512
$T3271 = 8						; size = 4
_kFile$ = 12						; size = 60
_filename$ = 72						; size = 4
?fsys_fat_open_subdir@@YA?AU_FILE@@U1@PBD@Z PROC	; fsys_fat_open_subdir, COMDAT

; 151  : {

	sub	esp, 536				; 00000218H
	push	ebx
	push	edi

; 152  : 	FILE file;
; 153  : 
; 154  : 	char dos_name[11];
; 155  : 	to_dos_filename(filename,dos_name,11);

	mov	edi, DWORD PTR _filename$[esp+540]
	push	11					; 0000000bH
	lea	eax, DWORD PTR _dos_name$[esp+548]
	push	eax
	push	edi
	call	?to_dos_filename@@YAXPBDPADI@Z		; to_dos_filename

; 156  : 	dos_name[11] = 0;

	xor	ebx, ebx

; 157  : 	if(kFile.flags != FS_INVALID){

	mov	ecx, 2
	add	esp, 12					; 0000000cH
	cmp	DWORD PTR _kFile$[esp+572], ecx
	mov	BYTE PTR _dos_name$[esp+555], bl
	je	$LN7@fsys_fat_o

; 158  : 		while(! kFile.eof ){

	cmp	DWORD PTR _kFile$[esp+584], ebx
	jne	SHORT $LN7@fsys_fat_o
	push	esi

; 159  : 			unsigned char buf[512];
; 160  : 			fsys_fat_read(&file,buf,512);

	mov	esi, DWORD PTR $T3271[esp+544]
	push	512					; 00000200H
	lea	ecx, DWORD PTR _buf$3173[esp+552]
	push	ecx
	push	esi
	call	?fsys_fat_read@@YAXPAU_FILE@@PAEI@Z	; fsys_fat_read

; 161  : 
; 162  : 			DIRECTORY* pkDir = (DIRECTORY*)buf;
; 163  : 
; 164  : 			//	16 entries in buffer
; 165  : 			for(unsigned int i = 0;i < 16; i++){
; 166  : 				char name[11];
; 167  : 				memcpy(name,pkDir->Filename,11);

	push	11					; 0000000bH
	lea	edx, DWORD PTR _buf$3173[esp+564]
	push	edx
	lea	eax, DWORD PTR _name$3180[esp+568]
	push	eax
	call	?memcpy@@YAPAXPAXPBXI@Z			; memcpy

; 168  : 				name[11] = 0;
; 169  : 
; 170  : 				//	match?
; 171  : 				if(strcmp(name,dos_name) == 0){

	lea	ecx, DWORD PTR _dos_name$[esp+572]
	push	ecx
	lea	edx, DWORD PTR _name$3180[esp+576]
	push	edx
	mov	BYTE PTR _name$3180[esp+591], bl
	call	?strcmp@@YAHPBD0@Z			; strcmp
	add	esp, 32					; 00000020H
	test	eax, eax
	jne	SHORT $LN3@fsys_fat_o

; 172  : 					strcpy(file.name,filename);

	push	edi
	push	esi
	call	?strcpy@@YAPADPADPBD@Z			; strcpy

; 173  : 					file.id = 0;
; 174  : 					file.current_cluster = pkDir->FirstCluster;

	movzx	eax, WORD PTR _buf$3173[esp+582]

; 175  : 					file.file_len = pkDir->FileSize;

	mov	ecx, DWORD PTR _buf$3173[esp+584]
	add	esp, 8
	mov	DWORD PTR [esi+40], ebx
	mov	DWORD PTR [esi+52], eax
	mov	DWORD PTR [esi+36], ecx

; 176  : 					file.eof = 0;

	mov	DWORD PTR [esi+44], ebx
$LN3@fsys_fat_o:

; 177  : 				}
; 178  : 
; 179  : 				//	set file type
; 180  : 				if(pkDir->Attrib == 0x10){

	xor	edx, edx
	cmp	BYTE PTR _buf$3173[esp+559], 16		; 00000010H

; 181  : 					file.flags = FS_DIRECTORY;
; 182  : 				}
; 183  : 				else{
; 184  : 					file.flags = FS_FILE;
; 185  : 				}
; 186  : 
; 187  : 				return file;

	mov	eax, esi
	sete	dl
	mov	DWORD PTR [esi+32], edx
	pop	esi
	pop	edi
	pop	ebx

; 194  : 	return file;
; 195  : }

	add	esp, 536				; 00000218H
	ret	0
$LN7@fsys_fat_o:

; 188  : 			}
; 189  : 
; 190  : 			pkDir ++;
; 191  : 		}
; 192  : 	}
; 193  : 	file.flags = FS_INVALID;

	mov	eax, DWORD PTR $T3271[esp+540]
	pop	edi
	mov	DWORD PTR [eax+32], ecx
	pop	ebx

; 194  : 	return file;
; 195  : }

	add	esp, 536				; 00000218H
	ret	0
?fsys_fat_open_subdir@@YA?AU_FILE@@U1@PBD@Z ENDP	; fsys_fat_open_subdir
_TEXT	ENDS
PUBLIC	?fsys_fat_open@@YA?AU_FILE@@PBD@Z		; fsys_fat_open
EXTRN	?strchr@@YAPADPADH@Z:PROC			; strchr
; Function compile flags: /Ogtpy
;	COMDAT ?fsys_fat_open@@YA?AU_FILE@@PBD@Z
_TEXT	SEGMENT
_rootDir$ = -145					; size = 1
tv411 = -144						; size = 4
tv409 = -140						; size = 4
_pathname$3199 = -136					; size = 16
_ret$ = -120						; size = 60
_curDirectory$ = -120					; size = 60
$T3283 = -60						; size = 60
$T3281 = -60						; size = 60
$T3279 = -60						; size = 60
$T3277 = 8						; size = 4
_filename$ = 12						; size = 4
?fsys_fat_open@@YA?AU_FILE@@PBD@Z PROC			; fsys_fat_open, COMDAT

; 198  : {

	sub	esp, 148				; 00000094H
	push	ebx
	push	ebp
	push	esi

; 199  : 	FILE curDirectory;
; 200  : 	char* p = 0;
; 201  : 	bool rootDir=true;
; 202  : 	char* path = (char*) filename;
; 203  : 
; 204  : 	//! ANY_TASK '\'s in path?
; 205  : 	p = strchr (path, '\\');

	mov	esi, DWORD PTR _filename$[esp+156]
	push	edi
	push	92					; 0000005cH
	push	esi
	mov	BYTE PTR _rootDir$[esp+172], 1
	call	?strchr@@YAPADPADH@Z			; strchr
	mov	ebp, eax

; 206  : 	if (!p) {

	xor	ebx, ebx
	add	esp, 8
	cmp	ebp, ebx
	jne	SHORT $LN14@fsys_fat_o@2

; 207  : 		//! nope, must be in root directory, search it
; 208  : 		curDirectory = fsys_fat_directory (path);

	lea	eax, DWORD PTR $T3279[esp+164]
	push	esi
	push	eax
	call	?fsys_fat_directory@@YA?AU_FILE@@PBD@Z	; fsys_fat_directory
	mov	ecx, 15					; 0000000fH
	mov	esi, eax
	lea	edi, DWORD PTR _curDirectory$[esp+172]
	rep movsd
	add	esp, 8

; 209  : 
; 210  : 		//! found file?
; 211  : 		if (curDirectory.flags == FS_FILE)

	cmp	DWORD PTR _curDirectory$[esp+196], ebx

; 212  : 			return curDirectory;

	lea	ecx, DWORD PTR [ebx+15]
	jne	$LN13@fsys_fat_o@2
	mov	esi, eax

; 267  : 	return ret;

	mov	eax, DWORD PTR $T3277[esp+160]
	mov	edi, eax
	rep movsd

; 268  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 148				; 00000094H
	ret	0
$LN14@fsys_fat_o@2:

; 213  : 
; 214  : 		//! unable to find
; 215  : 		FILE ret;
; 216  : 		ret.flags = FS_INVALID;
; 217  : 		return ret;
; 218  : 	}
; 219  : 
; 220  : 	//! go to next character after first '\'
; 221  : 	p++;

	add	ebp, 1

; 222  : 
; 223  : 	while ( p ) {

	je	$LN31@fsys_fat_o@2
$LL12@fsys_fat_o@2:

; 224  : 
; 225  : 		//! get pathname
; 226  : 		char pathname[16];
; 227  : 		int i=0;
; 228  : 		for (i=0; i<16; i++) {

	mov	ecx, ebp
	xor	eax, eax
	neg	ecx
	lea	edx, DWORD PTR _pathname$3199[esp+ecx+166]
	lea	esi, DWORD PTR _pathname$3199[esp+ecx+164]
	lea	edi, DWORD PTR _pathname$3199[esp+ecx+165]
	lea	ecx, DWORD PTR _pathname$3199[esp+ecx+167]
	mov	DWORD PTR tv409[esp+164], edx
	mov	DWORD PTR tv411[esp+164], ecx
$LL30@fsys_fat_o@2:

; 229  : 
; 230  : 			//! if another '\' or end of line is reached, we are done
; 231  : 			if (p[i]=='\\' || p[i]=='\0')

	mov	dl, BYTE PTR [eax+ebp]
	cmp	dl, 92					; 0000005cH
	lea	ecx, DWORD PTR [eax+ebp]
	je	SHORT $LN19@fsys_fat_o@2
	test	dl, dl
	je	SHORT $LN19@fsys_fat_o@2

; 232  : 				break;
; 233  : 
; 234  : 			//! copy character
; 235  : 			pathname[i]=p[i];

	mov	BYTE PTR [esi+ecx], dl
	mov	dl, BYTE PTR [eax+ebp+1]
	cmp	dl, 92					; 0000005cH
	je	SHORT $LN23@fsys_fat_o@2

; 229  : 
; 230  : 			//! if another '\' or end of line is reached, we are done
; 231  : 			if (p[i]=='\\' || p[i]=='\0')

	test	dl, dl
	je	SHORT $LN23@fsys_fat_o@2

; 232  : 				break;
; 233  : 
; 234  : 			//! copy character
; 235  : 			pathname[i]=p[i];

	mov	BYTE PTR [edi+ecx], dl
	mov	dl, BYTE PTR [eax+ebp+2]
	cmp	dl, 92					; 0000005cH
	je	SHORT $LN25@fsys_fat_o@2

; 229  : 
; 230  : 			//! if another '\' or end of line is reached, we are done
; 231  : 			if (p[i]=='\\' || p[i]=='\0')

	test	dl, dl
	je	SHORT $LN25@fsys_fat_o@2

; 232  : 				break;
; 233  : 
; 234  : 			//! copy character
; 235  : 			pathname[i]=p[i];

	mov	ebx, DWORD PTR tv409[esp+164]
	mov	BYTE PTR [ebx+ecx], dl
	mov	dl, BYTE PTR [eax+ebp+3]
	cmp	dl, 92					; 0000005cH
	je	SHORT $LN28@fsys_fat_o@2

; 229  : 
; 230  : 			//! if another '\' or end of line is reached, we are done
; 231  : 			if (p[i]=='\\' || p[i]=='\0')

	test	dl, dl
	je	SHORT $LN28@fsys_fat_o@2

; 232  : 				break;
; 233  : 
; 234  : 			//! copy character
; 235  : 			pathname[i]=p[i];

	mov	ebx, DWORD PTR tv411[esp+164]
	add	eax, 4
	cmp	eax, 16					; 00000010H
	mov	BYTE PTR [ebx+ecx], dl
	jl	SHORT $LL30@fsys_fat_o@2
	jmp	SHORT $LN19@fsys_fat_o@2
$LN23@fsys_fat_o@2:

; 229  : 
; 230  : 			//! if another '\' or end of line is reached, we are done
; 231  : 			if (p[i]=='\\' || p[i]=='\0')

	add	eax, 1
	jmp	SHORT $LN19@fsys_fat_o@2
$LN25@fsys_fat_o@2:
	add	eax, 2
	jmp	SHORT $LN19@fsys_fat_o@2
$LN28@fsys_fat_o@2:
	add	eax, 3
$LN19@fsys_fat_o@2:

; 236  : 		}
; 237  : 		pathname[i]=0; //null terminate

	xor	ebx, ebx

; 238  : 
; 239  : 		//! open subdirectory or file
; 240  : 		if (rootDir) {

	cmp	BYTE PTR _rootDir$[esp+164], bl
	mov	BYTE PTR _pathname$3199[esp+eax+164], bl
	je	SHORT $LN5@fsys_fat_o@2

; 241  : 			//! search root directory - open pathname
; 242  : 			curDirectory = fsys_fat_directory (pathname);

	lea	edx, DWORD PTR _pathname$3199[esp+164]
	push	edx
	lea	eax, DWORD PTR $T3281[esp+168]
	push	eax
	call	?fsys_fat_directory@@YA?AU_FILE@@PBD@Z	; fsys_fat_directory
	add	esp, 8

; 243  : 			rootDir=false;

	mov	BYTE PTR _rootDir$[esp+164], bl

; 244  : 		}
; 245  : 		else {

	jmp	SHORT $LN33@fsys_fat_o@2
$LN5@fsys_fat_o@2:

; 246  : 			//! search a subdirectory instead for pathname
; 247  : 			curDirectory = fsys_fat_open_subdir (curDirectory, pathname);

	lea	ecx, DWORD PTR _pathname$3199[esp+164]
	push	ecx
	sub	esp, 60					; 0000003cH
	lea	edx, DWORD PTR $T3283[esp+228]
	mov	edi, esp
	mov	ecx, 15					; 0000000fH
	lea	esi, DWORD PTR _curDirectory$[esp+228]
	push	edx
	rep movsd
	call	?fsys_fat_open_subdir@@YA?AU_FILE@@U1@PBD@Z ; fsys_fat_open_subdir
	add	esp, 68					; 00000044H
$LN33@fsys_fat_o@2:
	mov	esi, eax
	mov	ecx, 15					; 0000000fH
	lea	edi, DWORD PTR _curDirectory$[esp+164]
	rep movsd

; 248  : 		}
; 249  : 
; 250  : 		//! found directory or file?
; 251  : 		if (curDirectory.flags == FS_INVALID)

	mov	eax, DWORD PTR _curDirectory$[esp+196]
	cmp	eax, 2
	je	SHORT $LN31@fsys_fat_o@2

; 252  : 			break;
; 253  : 
; 254  : 		//! found file?
; 255  : 		if (curDirectory.flags == FS_FILE)

	cmp	eax, ebx
	je	SHORT $LN21@fsys_fat_o@2

; 257  : 
; 258  : 		//! find next '\'
; 259  : 		p=strchr (p+1, '\\');

	push	92					; 0000005cH
	add	ebp, 1
	push	ebp
	call	?strchr@@YAPADPADH@Z			; strchr
	mov	ebp, eax
	add	esp, 8

; 260  : 		if (p)

	cmp	ebp, ebx
	je	SHORT $LN31@fsys_fat_o@2

; 261  : 			p++;

	add	ebp, 1

; 222  : 
; 223  : 	while ( p ) {

	jne	$LL12@fsys_fat_o@2
$LN31@fsys_fat_o@2:

; 267  : 	return ret;

	mov	ecx, 15					; 0000000fH
$LN13@fsys_fat_o@2:

; 262  : 	}
; 263  : 
; 264  : 	//! unable to find
; 265  : 	FILE ret;
; 266  : 	ret.flags = FS_INVALID;

	mov	DWORD PTR _ret$[esp+196], 2
$LN34@fsys_fat_o@2:

; 267  : 	return ret;

	mov	eax, DWORD PTR $T3277[esp+160]
	lea	esi, DWORD PTR _ret$[esp+164]
	mov	edi, eax
	rep movsd

; 268  : }

	pop	edi
	pop	esi
	pop	ebp
	pop	ebx
	add	esp, 148				; 00000094H
	ret	0
$LN21@fsys_fat_o@2:

; 256  : 			return curDirectory;

	mov	ecx, 15					; 0000000fH
	jmp	SHORT $LN34@fsys_fat_o@2
?fsys_fat_open@@YA?AU_FILE@@PBD@Z ENDP			; fsys_fat_open
_TEXT	ENDS
PUBLIC	?fsys_fat_mount@@YAXXZ				; fsys_fat_mount
; Function compile flags: /Ogtpy
;	COMDAT ?fsys_fat_mount@@YAXXZ
_TEXT	SEGMENT
?fsys_fat_mount@@YAXXZ PROC				; fsys_fat_mount, COMDAT

; 272  : 	BOOTSECTOR*	bootsector;
; 273  : 
; 274  : 	bootsector = (BOOTSECTOR*)flpy_do_read_sector(0);//flpydsk_read_sector(0);

	push	0
	call	?flpy_do_read_sector@@YAPAEH@Z		; flpy_do_read_sector
	mov	ecx, eax

; 275  : 
; 276  : 	//	store mount info
; 277  : 	_mnt_info.numSectors		= bootsector->Bpb.NumSectors;

	movzx	eax, WORD PTR [ecx+19]
	mov	DWORD PTR ?_mnt_info@@3U_MOUNT_INFO@@A, eax

; 278  : 	_mnt_info.fatOffset			= 1;

	mov	DWORD PTR ?_mnt_info@@3U_MOUNT_INFO@@A+4, 1

; 279  : 	_mnt_info.fatSize			= bootsector->Bpb.SectorsPerFat;

	movzx	edx, WORD PTR [ecx+22]
	mov	DWORD PTR ?_mnt_info@@3U_MOUNT_INFO@@A+20, edx

; 280  : 	_mnt_info.fatEntrySize		= 8;

	mov	DWORD PTR ?_mnt_info@@3U_MOUNT_INFO@@A+24, 8

; 281  : 	_mnt_info.numRootEntries	= bootsector->Bpb.NumDirEntries;

	movzx	eax, WORD PTR [ecx+17]
	mov	DWORD PTR ?_mnt_info@@3U_MOUNT_INFO@@A+8, eax

; 282  : 	_mnt_info.rootOffset		= (bootsector->Bpb.NumberOfFats * bootsector->Bpb.SectorsPerFat) + 1;

	movzx	eax, WORD PTR [ecx+22]
	movzx	edx, BYTE PTR [ecx+16]
	imul	edx, eax
	add	edx, 1
	mov	DWORD PTR ?_mnt_info@@3U_MOUNT_INFO@@A+12, edx

; 283  : 	_mnt_info.rootSize			= ( bootsector->Bpb.NumDirEntries * 32 ) / bootsector->Bpb.BytesPerSector;

	movzx	eax, WORD PTR [ecx+17]
	movzx	ecx, WORD PTR [ecx+11]
	shl	eax, 5
	cdq
	idiv	ecx
	add	esp, 4
	mov	DWORD PTR ?_mnt_info@@3U_MOUNT_INFO@@A+16, eax

; 284  : }

	ret	0
?fsys_fat_mount@@YAXXZ ENDP				; fsys_fat_mount
_TEXT	ENDS
PUBLIC	??_C@_05HOBJIFPH@FAT12?$AA@			; `string'
PUBLIC	?fsys_fat_initialize@@YAXXZ			; fsys_fat_initialize
EXTRN	?volRegisterFileSystem@@YAXPAU_FILE_SYS@@I@Z:PROC ; volRegisterFileSystem
;	COMDAT ??_C@_05HOBJIFPH@FAT12?$AA@
CONST	SEGMENT
??_C@_05HOBJIFPH@FAT12?$AA@ DB 'FAT12', 00H		; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?fsys_fat_initialize@@YAXXZ
_TEXT	SEGMENT
?fsys_fat_initialize@@YAXXZ PROC			; fsys_fat_initialize, COMDAT

; 288  : 	strcpy(_fs_fat.name,"FAT12");

	push	OFFSET ??_C@_05HOBJIFPH@FAT12?$AA@
	push	OFFSET ?_fs_fat@@3U_FILE_SYS@@A		; _fs_fat
	call	?strcpy@@YAPADPADPBD@Z			; strcpy

; 289  : 	_fs_fat.directory = fsys_fat_directory;
; 290  : 	_fs_fat.mount     = fsys_fat_mount;
; 291  : 	_fs_fat.open      = fsys_fat_open;
; 292  : 	_fs_fat.read      = fsys_fat_read;
; 293  : 	_fs_fat.close     = fsys_fat_close;
; 294  : 
; 295  : 	//! register ourself to volume manager
; 296  : 	volRegisterFileSystem ( &_fs_fat, 0 );

	push	0
	push	OFFSET ?_fs_fat@@3U_FILE_SYS@@A		; _fs_fat
	mov	DWORD PTR ?_fs_fat@@3U_FILE_SYS@@A+8, OFFSET ?fsys_fat_directory@@YA?AU_FILE@@PBD@Z ; fsys_fat_directory
	mov	DWORD PTR ?_fs_fat@@3U_FILE_SYS@@A+12, OFFSET ?fsys_fat_mount@@YAXXZ ; fsys_fat_mount
	mov	DWORD PTR ?_fs_fat@@3U_FILE_SYS@@A+24, OFFSET ?fsys_fat_open@@YA?AU_FILE@@PBD@Z ; fsys_fat_open
	mov	DWORD PTR ?_fs_fat@@3U_FILE_SYS@@A+16, OFFSET ?fsys_fat_read@@YAXPAU_FILE@@PAEI@Z ; fsys_fat_read
	mov	DWORD PTR ?_fs_fat@@3U_FILE_SYS@@A+20, OFFSET ?fsys_fat_close@@YAXPAU_FILE@@@Z ; fsys_fat_close
	call	?volRegisterFileSystem@@YAXPAU_FILE_SYS@@I@Z ; volRegisterFileSystem
	add	esp, 16					; 00000010H

; 297  : 
; 298  : 	//! mounr filesystem
; 299  : 	fsys_fat_mount();

	jmp	?fsys_fat_mount@@YAXXZ			; fsys_fat_mount
?fsys_fat_initialize@@YAXXZ ENDP			; fsys_fat_initialize
_TEXT	ENDS
END
