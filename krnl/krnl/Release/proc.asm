; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	i:\os\10\a\krnl\krnl\proc.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?Init@@YAXXZ					; Init
PUBLIC	?TestA@@YAXXZ					; TestA
PUBLIC	?p_proc_ready@@3PAU_tagPROC@@A			; p_proc_ready
PUBLIC	?ticks@@3IA					; ticks
PUBLIC	?proc_table@@3PAU_tagPROC@@A			; proc_table
PUBLIC	?tss@@3U_tagTSS@@A				; tss
PUBLIC	?stack_top@@3U<unnamed-tag>@@A			; stack_top
PUBLIC	?ldtr@@3GA					; ldtr
PUBLIC	?save_ret_addr@@3IA				; save_ret_addr
PUBLIC	?task_table@@3PAU_tagTASK@@A			; task_table
PUBLIC	?user_proc_table@@3PAU_tagTASK@@A		; user_proc_table
PUBLIC	?task_stack@@3PADA				; task_stack
EXTRN	?task_fs@@YAXXZ:PROC				; task_fs
EXTRN	?task_flpy@@YAXXZ:PROC				; task_flpy
EXTRN	?task_sys@@YAXXZ:PROC				; task_sys
EXTRN	?task_tty@@YAXXZ:PROC				; task_tty
_BSS	SEGMENT
?p_proc_ready@@3PAU_tagPROC@@A DD 01H DUP (?)		; p_proc_ready
?ticks@@3IA DD	01H DUP (?)				; ticks
?proc_table@@3PAU_tagPROC@@A DB 01b48H DUP (?)		; proc_table
?tss@@3U_tagTSS@@A DB 06cH DUP (?)			; tss
?stack_top@@3U<unnamed-tag>@@A DB 0801H DUP (?)		; stack_top
	ALIGN	4

?ldtr@@3GA DW	01H DUP (?)				; ldtr
	ALIGN	4

?save_ret_addr@@3IA DD 01H DUP (?)			; save_ret_addr
_BSS	ENDS
_DATA	SEGMENT
?task_table@@3PAU_tagTASK@@A DD FLAT:?task_tty@@YAXXZ	; task_table
	DD	01000H
	DB	'tty', 00H
	ORG $+16
	DD	FLAT:?task_sys@@YAXXZ
	DD	01000H
	DB	'sys', 00H
	ORG $+16
	DD	FLAT:?task_flpy@@YAXXZ
	DD	01000H
	DB	'flpy', 00H
	ORG $+15
	DD	FLAT:?task_fs@@YAXXZ
	DD	01000H
	DB	'fsys', 00H
	ORG $+15
?user_proc_table@@3PAU_tagTASK@@A DD FLAT:?TestA@@YAXXZ	; user_proc_table
	DD	0500H
	DB	'TestA', 00H
	ORG $+14
	DD	FLAT:?Init@@YAXXZ
	DD	0500H
	DB	'Init', 00H
	ORG $+15
?task_stack@@3PADA DD 0100000H				; task_stack
_DATA	ENDS
PUBLIC	?delay@@YAXI@Z					; delay
; Function compile flags: /Ogtpy
; File i:\os\10\a\krnl\krnl\proc.cpp
;	COMDAT ?delay@@YAXI@Z
_TEXT	SEGMENT
_t$ = 8							; size = 4
?delay@@YAXI@Z PROC					; delay, COMDAT

; 75   : 	int  j ,k;
; 76   : 	for(k=0;k < t;k++){

	mov	eax, DWORD PTR _t$[esp-4]
	test	eax, eax
	jbe	SHORT $LN4@delay
	mov	ecx, eax
	npad	6
$LL6@delay:

; 77   : 		for(j=0;j<100;j++){

	mov	eax, 100				; 00000064H
$LL3@delay:

; 78   : 			_asm nop

	npad	1
	sub	eax, 1
	jne	SHORT $LL3@delay

; 75   : 	int  j ,k;
; 76   : 	for(k=0;k < t;k++){

	sub	ecx, 1
	jne	SHORT $LL6@delay
$LN4@delay:

; 79   : 		}
; 80   : 	}
; 81   : }

	ret	0
?delay@@YAXI@Z ENDP					; delay
_TEXT	ENDS
PUBLIC	?ldt_set_descriptor@@YAXPAU_tagLDT_DESCRIPTOR@@IIG@Z ; ldt_set_descriptor
; Function compile flags: /Ogtpy
;	COMDAT ?ldt_set_descriptor@@YAXPAU_tagLDT_DESCRIPTOR@@IIG@Z
_TEXT	SEGMENT
_desc$ = 8						; size = 4
_base$ = 12						; size = 4
_limit$ = 16						; size = 4
_attr$ = 20						; size = 2
?ldt_set_descriptor@@YAXPAU_tagLDT_DESCRIPTOR@@IIG@Z PROC ; ldt_set_descriptor, COMDAT

; 85   : 	desc->baseLo	= (uint16_t)(base & 0xffff);

	mov	eax, DWORD PTR _desc$[esp-4]
	mov	ecx, DWORD PTR _base$[esp-4]
	push	ebx

; 86   : 	desc->baseMid	= (uint8_t)((base >>16) & 0xff);

	mov	edx, ecx
	shr	edx, 16					; 00000010H
	mov	WORD PTR [eax+2], cx
	push	esi

; 87   : 	desc->baseHi	= (uint8_t)((base >> 24) & 0xff);
; 88   : 	desc->limit		= (uint16_t)(limit & 0xffff);

	mov	esi, DWORD PTR _limit$[esp+4]
	mov	BYTE PTR [eax+4], dl
	shr	ecx, 24					; 00000018H
	mov	BYTE PTR [eax+7], cl

; 89   : 	desc->flags		= (attr & 0xff);

	mov	cx, WORD PTR _attr$[esp+4]

; 90   : 	desc->grand		= ((attr >> 8) & 0xf0) | (uint8_t)((limit >> 16) & 0x0f);

	mov	edx, esi
	shr	edx, 16					; 00000010H
	mov	bl, ch
	xor	dl, bl
	mov	BYTE PTR [eax+5], cl
	and	dl, 15					; 0000000fH
	mov	cl, ch
	mov	WORD PTR [eax], si
	xor	dl, cl
	pop	esi
	mov	BYTE PTR [eax+6], dl
	pop	ebx

; 91   : }

	ret	0
?ldt_set_descriptor@@YAXPAU_tagLDT_DESCRIPTOR@@IIG@Z ENDP ; ldt_set_descriptor
_TEXT	ENDS
PUBLIC	?i86_ldt_initialize@@YAHXZ			; i86_ldt_initialize
EXTRN	?gdt_set_descriptor@@YAXIIIG@Z:PROC		; gdt_set_descriptor
; Function compile flags: /Ogtpy
;	COMDAT ?i86_ldt_initialize@@YAHXZ
_TEXT	SEGMENT
?i86_ldt_initialize@@YAHXZ PROC				; i86_ldt_initialize, COMDAT

; 165  : {

	push	ebx
	push	esi
	push	edi

; 166  : 	PROCESS* p_proc = proc_table;
; 167  : 	uint16_t	selector_ldt = SELECTOR_LDT_FIRST;

	mov	esi, 32					; 00000020H
	mov	ebx, OFFSET ?proc_table@@3PAU_tagPROC@@A+74
	mov	edi, OFFSET ?proc_table@@3PAU_tagPROC@@A+72
$LL3@i86_ldt_in:

; 168  : 	int i;
; 169  : 	for(i=0;i<NR_TASKS+NR_PROCS;i++){
; 170  : 		proc_table[i].ldt_sel = selector_ldt;
; 171  : 		gdt_set_descriptor(selector_ldt >> 3,(uint32_t)&p_proc->ldts,
; 172  : 			LDT_SIZE * sizeof(LDT_DESCRIPTOR) - 1,DA_LDT);

	push	130					; 00000082H
	movzx	eax, si
	push	15					; 0000000fH
	shr	eax, 3
	push	ebx
	push	eax
	mov	WORD PTR [edi], si
	call	?gdt_set_descriptor@@YAXIIIG@Z		; gdt_set_descriptor
	add	edi, 194				; 000000c2H
	add	esp, 16					; 00000010H

; 173  : 		p_proc ++;

	add	ebx, 194				; 000000c2H

; 174  : 		selector_ldt += (1 << 3);

	add	esi, 8
	cmp	edi, OFFSET ?proc_table@@3PAU_tagPROC@@A+7056
	jl	SHORT $LL3@i86_ldt_in
	pop	edi
	pop	esi

; 175  : 	}
; 176  : 	
; 177  : 	return 0;

	xor	eax, eax
	pop	ebx

; 178  : }

	ret	0
?i86_ldt_initialize@@YAHXZ ENDP				; i86_ldt_initialize
_TEXT	ENDS
PUBLIC	?i86_tss_initialize@@YAHXZ			; i86_tss_initialize
EXTRN	?memset@@YAPAXPAXDI@Z:PROC			; memset
; Function compile flags: /Ogtpy
;	COMDAT ?i86_tss_initialize@@YAHXZ
_TEXT	SEGMENT
?i86_tss_initialize@@YAHXZ PROC				; i86_tss_initialize, COMDAT

; 182  : 	memset(&tss,0,sizeof(tss));

	push	108					; 0000006cH
	push	0
	push	OFFSET ?tss@@3U_tagTSS@@A		; tss
	call	?memset@@YAPAXPAXDI@Z			; memset

; 183  : 	tss.ss0 = SELECTOR_KERNEL_DS;
; 184  : 	tss.cs = SELECTOR_KERNEL_CS;
; 185  : 	gdt_set_descriptor(SELECTOR_TSS >> 3,(uint32_t)&tss,
; 186  : 		sizeof(tss) - 1,DA_386TSS);

	push	137					; 00000089H
	push	107					; 0000006bH
	push	OFFSET ?tss@@3U_tagTSS@@A		; tss
	push	3
	mov	DWORD PTR ?tss@@3U_tagTSS@@A+8, 16	; 00000010H
	mov	DWORD PTR ?tss@@3U_tagTSS@@A+76, 8
	call	?gdt_set_descriptor@@YAXIIIG@Z		; gdt_set_descriptor
	add	esp, 28					; 0000001cH

; 187  : 	tss.iobase = sizeof(tss);

	mov	DWORD PTR ?tss@@3U_tagTSS@@A+104, 108	; 0000006cH

; 188  : 
; 189  : 	_asm{
; 190  : 		xor	eax,eax

	xor	eax, eax

; 191  : 		mov ax,SELECTOR_TSS

	mov	ax, 24					; 00000018H

; 192  : 		ltr	ax

	ltr	ax

; 193  : 	}
; 194  : 
; 195  : 	return 0;

	xor	eax, eax

; 196  : }

	ret	0
?i86_tss_initialize@@YAHXZ ENDP				; i86_tss_initialize
_TEXT	ENDS
PUBLIC	?restart@@YAXXZ					; restart
EXTRN	?k_reenter@@3HA:DWORD				; k_reenter
; Function compile flags: /Ogtpy
;	COMDAT ?restart@@YAXXZ
_TEXT	SEGMENT
?restart@@YAXXZ PROC					; restart, COMDAT

; 216  : 	ldtr = p_proc_ready->ldt_sel;

	mov	eax, DWORD PTR ?p_proc_ready@@3PAU_tagPROC@@A ; p_proc_ready
	mov	cx, WORD PTR [eax+72]
	mov	WORD PTR ?ldtr@@3GA, cx			; ldtr

; 217  : 	_asm{
; 218  : 		mov	esp,[p_proc_ready]

	mov	esp, DWORD PTR ?p_proc_ready@@3PAU_tagPROC@@A ; p_proc_ready

; 219  : 		lldt [ldtr]

	lldt	WORD PTR ?ldtr@@3GA			; ldtr

; 220  : 	}
; 221  : 	tss.esp0 =(uint32_t) & p_proc_ready->ldt_sel;	//	esp0 in tss point to stack frame

	mov	edx, DWORD PTR ?p_proc_ready@@3PAU_tagPROC@@A ; p_proc_ready
	add	edx, 72					; 00000048H

; 222  : 	k_reenter --;

	sub	DWORD PTR ?k_reenter@@3HA, 1		; k_reenter
	mov	DWORD PTR ?tss@@3U_tagTSS@@A+4, edx

; 223  : 	_asm{
; 224  : 		pop	gs

	pop	gs

; 225  : 		pop	fs

	pop	fs

; 226  : 		pop	es

	pop	es

; 227  : 		pop	ds

	pop	ds

; 228  : 		popad

	popad

; 229  : 
; 230  : 		add	esp,4

	add	esp, 4

; 231  : 	}
; 232  : 	_asm iretd

	iretd
?restart@@YAXXZ ENDP					; restart
_TEXT	ENDS
PUBLIC	?task_start@@YAXXZ				; task_start
; Function compile flags: /Ogtpy
;	COMDAT ?task_start@@YAXXZ
_TEXT	SEGMENT
?task_start@@YAXXZ PROC					; task_start, COMDAT

; 237  : 	restart();

	jmp	?restart@@YAXXZ				; restart
?task_start@@YAXXZ ENDP					; task_start
_TEXT	ENDS
PUBLIC	?restart_reenter@@YAXXZ				; restart_reenter
; Function compile flags: /Ogtpy
;	COMDAT ?restart_reenter@@YAXXZ
_TEXT	SEGMENT
?restart_reenter@@YAXXZ PROC				; restart_reenter, COMDAT

; 242  : 	k_reenter --;

	sub	DWORD PTR ?k_reenter@@3HA, 1		; k_reenter

; 243  : 	_asm{
; 244  : 		pop	gs

	pop	gs

; 245  : 		pop	fs

	pop	fs

; 246  : 		pop	es

	pop	es

; 247  : 		pop	ds

	pop	ds

; 248  : 		popad

	popad

; 249  : 
; 250  : 		add	esp,4

	add	esp, 4

; 251  : 	}
; 252  : 	_asm iretd

	iretd
?restart_reenter@@YAXXZ ENDP				; restart_reenter
_TEXT	ENDS
PUBLIC	?_save@@YAXXZ					; _save
; Function compile flags: /Odtpy
;	COMDAT ?_save@@YAXXZ
_TEXT	SEGMENT
?_save@@YAXXZ PROC					; _save, COMDAT

; 259  : 	_asm mov eax,[esp]

	mov	eax, DWORD PTR [esp]

; 260  : 	_asm add esp,4

	add	esp, 4

; 261  : 	_asm mov save_ret_addr,eax

	mov	DWORD PTR ?save_ret_addr@@3IA, eax	; save_ret_addr

; 262  : 	_asm{
; 263  : 		push ds

	push	ds

; 264  : 		push es

	push	es

; 265  : 		push fs

	push	fs

; 266  : 		push gs

	push	gs

; 267  : 
; 268  : 		mov esi,edx

	mov	esi, edx

; 269  : 
; 270  : 		mov dx,ss

	mov	dx, ss

; 271  : 		mov ds,dx

	mov	ds, dx

; 272  : 		mov es,dx

	mov	es, dx

; 273  : 
; 274  : 		mov edx,esi

	mov	edx, esi

; 275  : 
; 276  : 		mov esi,esp

	mov	esi, esp

; 277  : 	}
; 278  : 	//	re-enable interrupt
; 279  : 	k_reenter ++;

	mov	eax, DWORD PTR ?k_reenter@@3HA		; k_reenter
	add	eax, 1
	mov	DWORD PTR ?k_reenter@@3HA, eax		; k_reenter

; 280  : 	if(k_reenter == 0){

	jne	SHORT $LN2@save

; 281  : 		_asm{
; 282  : 			lea esp,[stack_top.stack_top]	//	switch to kernel stack

	lea	esp, OFFSET ?stack_top@@3U<unnamed-tag>@@A+2048

; 283  : 			push restart

	push	OFFSET ?restart@@YAXXZ			; restart

; 284  : 		}
; 285  : 	}
; 286  : 	else{

	jmp	SHORT $LN1@save
$LN2@save:

; 287  : 		_asm{
; 288  : 			push restart_reenter

	push	OFFSET ?restart_reenter@@YAXXZ		; restart_reenter
$LN1@save:

; 289  : 		}
; 290  : 	}
; 291  : 	_asm mov eax,save_ret_addr

	mov	eax, DWORD PTR ?save_ret_addr@@3IA	; save_ret_addr

; 292  : 	_asm jmp eax

	jmp	eax
?_save@@YAXXZ ENDP					; _save
_TEXT	ENDS
PUBLIC	?schedule@@YAXXZ				; schedule
; Function compile flags: /Ogtpy
;	COMDAT ?schedule@@YAXXZ
_TEXT	SEGMENT
?schedule@@YAXXZ PROC					; schedule, COMDAT

; 328  : {

	mov	eax, DWORD PTR ?p_proc_ready@@3PAU_tagPROC@@A ; p_proc_ready
	mov	edx, 56					; 00000038H
	lea	ecx, DWORD PTR [edx-59]
	npad	3
$LL5@schedule:

; 329  : 	int p = (int)p_proc_ready;
; 330  : 	do{
; 331  : 		p_proc_ready ++;

	add	eax, 194				; 000000c2H

; 332  : 		if((p_proc_ready >= proc_table+NR_TASKS+NR_PROCS)){

	cmp	eax, OFFSET ?proc_table@@3PAU_tagPROC@@A+6984
	mov	DWORD PTR ?p_proc_ready@@3PAU_tagPROC@@A, eax ; p_proc_ready
	jb	SHORT $LN2@schedule

; 333  : 			p_proc_ready = proc_table;

	mov	eax, OFFSET ?proc_table@@3PAU_tagPROC@@A ; proc_table
	mov	DWORD PTR ?p_proc_ready@@3PAU_tagPROC@@A, eax ; p_proc_ready
$LN2@schedule:

; 334  : 		}
; 335  : 		if(p_proc_ready->p_recvfrom == NO_TASK) p_proc_ready->p_flags&= ~RECEIVE;

	cmp	DWORD PTR [eax+126], edx
	jne	SHORT $LN4@schedule
	and	DWORD PTR [eax+118], ecx
	mov	eax, DWORD PTR ?p_proc_ready@@3PAU_tagPROC@@A ; p_proc_ready
$LN4@schedule:

; 336  : 	}while(p_proc_ready->p_flags != 0);

	cmp	DWORD PTR [eax+118], 0
	jne	SHORT $LL5@schedule

; 337  : 	//if(p_proc_ready->pid == 5)DbgPrintf("f%d",p_proc_ready->p_flags);
; 338  : 	//if(proc_table[4].p_flags & HANGING)DbgPrintf("H");
; 339  : 	//DbgPrintf("%d ",proc_table[4].p_flags);
; 340  : 	//DbgPrintf("%d",proc_table[6].p_flags);
; 341  : 	//if(p != (int)p_proc_ready)DbgPrintf("%d",p_proc_ready->pid);
; 342  : }

	ret	0
?schedule@@YAXXZ ENDP					; schedule
_TEXT	ENDS
PUBLIC	?milli_delay@@YAXH@Z				; milli_delay
EXTRN	?get_ticks@@YAHXZ:PROC				; get_ticks
; Function compile flags: /Ogtpy
;	COMDAT ?milli_delay@@YAXH@Z
_TEXT	SEGMENT
_milli_sec$ = 8						; size = 4
?milli_delay@@YAXH@Z PROC				; milli_delay, COMDAT

; 345  : {

	push	esi
	push	edi

; 346  : 	int t = get_ticks();

	call	?get_ticks@@YAHXZ			; get_ticks
	mov	esi, DWORD PTR _milli_sec$[esp+4]
	mov	edi, eax
	npad	3
$LL2@milli_dela:

; 347  : 	while(((get_ticks() - t) * 1000 / HZ) < milli_sec){}

	call	?get_ticks@@YAHXZ			; get_ticks
	mov	ecx, eax
	sub	ecx, edi
	imul	ecx, 1000				; 000003e8H
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, esi
	jl	SHORT $LL2@milli_dela
	pop	edi
	pop	esi

; 348  : }

	ret	0
?milli_delay@@YAXH@Z ENDP				; milli_delay
_TEXT	ENDS
PUBLIC	?get_kernel_map@@YAXPAI0@Z			; get_kernel_map
EXTRN	?kernelSize@@3GA:WORD				; kernelSize
; Function compile flags: /Ogtpy
;	COMDAT ?get_kernel_map@@YAXPAI0@Z
_TEXT	SEGMENT
_base$ = 8						; size = 4
_limit$ = 12						; size = 4
?get_kernel_map@@YAXPAI0@Z PROC				; get_kernel_map, COMDAT

; 353  : 	*base = KERNEL_ADDR;

	mov	eax, DWORD PTR _base$[esp-4]

; 354  : 	*limit = kernelSize*512 - 1;

	mov	edx, DWORD PTR _limit$[esp-4]
	mov	DWORD PTR [eax], 262144			; 00040000H
	movzx	ecx, WORD PTR ?kernelSize@@3GA		; kernelSize
	shl	ecx, 9
	sub	ecx, 1
	mov	DWORD PTR [edx], ecx

; 355  : }

	ret	0
?get_kernel_map@@YAXPAI0@Z ENDP				; get_kernel_map
_TEXT	ENDS
EXTRN	?exit@@YAXH@Z:PROC				; exit
; Function compile flags: /Ogtpy
;	COMDAT ?TestA@@YAXXZ
_TEXT	SEGMENT
?TestA@@YAXXZ PROC					; TestA, COMDAT

; 54   : {

	push	esi
	push	edi

; 55   : 	int i = 0;

	xor	edi, edi
$LL3@TestA:

; 56   : 	while(1){
; 57   : 		//printf("A%d",i);
; 58   : 		i++;

	add	edi, 1

; 59   : 		if(i >= 127) exit(0);

	cmp	edi, 127				; 0000007fH
	jl	SHORT $LN1@TestA
	push	0
	call	?exit@@YAXH@Z				; exit
	add	esp, 4
$LN1@TestA:

; 60   : 		milli_delay(1000);

	call	?get_ticks@@YAHXZ			; get_ticks
	mov	esi, eax
	npad	3
$LL7@TestA:
	call	?get_ticks@@YAHXZ			; get_ticks
	mov	ecx, eax
	sub	ecx, esi
	imul	ecx, 1000				; 000003e8H
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, 1000				; 000003e8H
	jl	SHORT $LL7@TestA

; 61   : 	}

	jmp	SHORT $LL3@TestA
?TestA@@YAXXZ ENDP					; TestA
_TEXT	ENDS
PUBLIC	??_C@_05KPFBFMFL@Init?6?$AA@			; `string'
EXTRN	?printf@@YAHPBDZZ:PROC				; printf
;	COMDAT ??_C@_05KPFBFMFL@Init?6?$AA@
CONST	SEGMENT
??_C@_05KPFBFMFL@Init?6?$AA@ DB 'Init', 0aH, 00H	; `string'
; Function compile flags: /Ogtpy
CONST	ENDS
;	COMDAT ?Init@@YAXXZ
_TEXT	SEGMENT
?Init@@YAXXZ PROC					; Init, COMDAT

; 65   : {

	push	esi

; 66   : 	int i = 0;
; 67   : 	printf("Init\n");

	push	OFFSET ??_C@_05KPFBFMFL@Init?6?$AA@
	call	?printf@@YAHPBDZZ			; printf
	add	esp, 4
	npad	2
$LL2@Init:

; 68   : 	while(1){
; 69   : 		milli_delay(1);

	call	?get_ticks@@YAHXZ			; get_ticks
	mov	esi, eax
$LL6@Init:
	call	?get_ticks@@YAHXZ			; get_ticks
	mov	ecx, eax
	sub	ecx, esi
	imul	ecx, 1000				; 000003e8H
	mov	eax, 1374389535				; 51eb851fH
	imul	ecx
	sar	edx, 5
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx
	cmp	eax, 1
	jl	SHORT $LL6@Init

; 70   : 	}

	jmp	SHORT $LL2@Init
?Init@@YAXXZ ENDP					; Init
_TEXT	ENDS
PUBLIC	?init_proc@@YAXXZ				; init_proc
EXTRN	?memcpy@@YAPAXPAXPBXI@Z:PROC			; memcpy
EXTRN	?_gdt@@3PAUgdt_descriptor@@A:BYTE		; _gdt
EXTRN	?strcpy@@YAPADPADPBD@Z:PROC			; strcpy
; Function compile flags: /Ogtpy
;	COMDAT ?init_proc@@YAXXZ
_TEXT	SEGMENT
_rpl$ = -21						; size = 1
_selector_ldt$ = -20					; size = 2
_i$ = -16						; size = 4
tv438 = -12						; size = 4
_eflags$ = -8						; size = 4
tv445 = -4						; size = 4
?init_proc@@YAXXZ PROC					; init_proc, COMDAT

; 94   : {

	sub	esp, 24					; 00000018H
	push	ebx
	push	ebp
	push	esi
	push	edi

; 95   : 	i86_tss_initialize();

	call	?i86_tss_initialize@@YAHXZ		; i86_tss_initialize

; 96   : 	i86_ldt_initialize();

	call	?i86_ldt_initialize@@YAHXZ		; i86_ldt_initialize

; 97   : 	TASK*	p_task = task_table;
; 98   : 	PROCESS*	p_proc = proc_table;
; 99   : 	char*	p_task_stack = task_stack + STACK_SIZE_TOTAL;

	mov	ebp, DWORD PTR ?task_stack@@3PADA	; task_stack

; 100  : 	uint16_t	selector_ldt = SELECTOR_LDT_FIRST;
; 101  : 
; 102  : 	uint8_t		privilage;
; 103  : 	uint8_t		rpl;
; 104  : 	int32_t		eflags;
; 105  : 
; 106  : 	int i;
; 107  : 	for(i=0;i<NR_TASKS+NR_PROCS;i++){

	xor	eax, eax
	mov	edi, OFFSET ?user_proc_table@@3PAU_tagTASK@@A
	add	ebp, 18944				; 00004a00H
	sub	edi, 112				; 00000070H
	mov	esi, OFFSET ?proc_table@@3PAU_tagPROC@@A ; proc_table
	mov	DWORD PTR _selector_ldt$[esp+40], 32	; 00000020H
	mov	DWORD PTR _i$[esp+40], eax
	mov	DWORD PTR tv438[esp+40], OFFSET ?task_table@@3PAU_tagTASK@@A
	mov	DWORD PTR tv445[esp+40], edi
$LL6@init_proc:

; 108  : 		if(i >= NR_TASKS+NR_NATIVE_PROCS){

	cmp	eax, 6
	jl	SHORT $LN3@init_proc

; 109  : 			p_proc->p_flags = FREE_SLOT;

	mov	DWORD PTR [esi+118], 8

; 110  : 			p_proc ++;

	add	esi, 194				; 000000c2H

; 111  : 			continue;

	jmp	$LN5@init_proc
$LN3@init_proc:

; 112  : 		}
; 113  : 
; 114  : 		if(i<NR_TASKS){

	cmp	eax, 4
	jge	SHORT $LN2@init_proc

; 115  : 			p_task = task_table + i;

	mov	edi, DWORD PTR tv438[esp+40]

; 116  : 			privilage = PRIVILEGE_TASK;

	mov	bl, 1

; 117  : 			rpl = RPL_TASK;
; 118  : 			eflags = 0x1202;

	mov	DWORD PTR _eflags$[esp+40], 4610	; 00001202H

; 119  : 		}
; 120  : 		else{

	jmp	SHORT $LN11@init_proc
$LN2@init_proc:

; 121  : 			p_task = user_proc_table + (i - NR_TASKS);
; 122  : 			privilage = PRIVILEGE_USER;

	mov	bl, 3

; 123  : 			rpl = RPL_USER;
; 124  : 			eflags = 0x202;

	mov	DWORD PTR _eflags$[esp+40], 514		; 00000202H
$LN11@init_proc:

; 125  : 		}
; 126  : 
; 127  : 		strcpy(p_proc->p_name,p_task->name);

	lea	eax, DWORD PTR [edi+8]
	push	eax
	lea	ecx, DWORD PTR [esi+94]
	push	ecx
	mov	BYTE PTR _rpl$[esp+48], bl
	call	?strcpy@@YAPADPADPBD@Z			; strcpy

; 128  : 		p_proc->pid = i;

	mov	edx, DWORD PTR _i$[esp+48]

; 129  : 		
; 130  : 		p_proc->ldt_sel = selector_ldt;

	mov	ax, WORD PTR _selector_ldt$[esp+48]

; 131  : 		memcpy(&p_proc->ldts[0],&_gdt[1],sizeof(LDT_DESCRIPTOR));

	push	8
	lea	ecx, DWORD PTR [esi+74]
	push	OFFSET ?_gdt@@3PAUgdt_descriptor@@A+8
	push	ecx
	mov	DWORD PTR [esi+90], edx
	mov	WORD PTR [esi+72], ax
	call	?memcpy@@YAPAXPAXPBXI@Z			; memcpy

; 132  : 		p_proc->ldts[0].flags = (DA_C | privilage << 5);

	shl	bl, 5

; 133  : 		memcpy(&p_proc->ldts[1],&_gdt[2],sizeof(LDT_DESCRIPTOR));

	push	8
	mov	dl, bl
	lea	eax, DWORD PTR [esi+82]
	or	dl, 152					; 00000098H
	push	OFFSET ?_gdt@@3PAUgdt_descriptor@@A+16
	push	eax
	mov	BYTE PTR [esi+79], dl
	call	?memcpy@@YAPAXPAXPBXI@Z			; memcpy

; 134  : 		p_proc->ldts[1].flags = (DA_DRW | privilage << 5);
; 135  : 
; 136  : 		p_proc->regs.cs = (8*0 & SA_RPL_MASK & SA_TI_MASK) | SA_TIL | rpl;

	movzx	eax, BYTE PTR _rpl$[esp+72]

; 137  : 		p_proc->regs.ds = (8*1 & SA_RPL_MASK & SA_TI_MASK) | SA_TIL | rpl;
; 138  : 		p_proc->regs.es = (8*1 & SA_RPL_MASK & SA_TI_MASK) | SA_TIL | rpl;
; 139  : 		p_proc->regs.fs = (8*1 & SA_RPL_MASK & SA_TI_MASK) | SA_TIL | rpl;
; 140  : 		p_proc->regs.gs = (8*1 & SA_RPL_MASK & SA_TI_MASK) | SA_TIL | rpl;
; 141  : 		p_proc->regs.ss = (8*1 & SA_RPL_MASK & SA_TI_MASK) | SA_TIL | rpl;
; 142  : 
; 143  : 		p_proc->regs.eip = (uint32_t)p_task->initial_eip;

	mov	edx, DWORD PTR [edi]
	mov	ecx, eax
	or	eax, 12					; 0000000cH
	or	ecx, 4

; 144  : 		p_proc->regs.esp = (uint32_t)p_task_stack;
; 145  : 		p_proc->regs.eflags = eflags;
; 146  : 
; 147  : 		memset(&p_proc->file_desc,INVALID_FILE_DESC,sizeof(int)*MAX_FILES_PER_PROCESS);

	push	32					; 00000020H
	mov	DWORD PTR [esi+56], ecx
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+4], eax
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+68], eax
	mov	eax, DWORD PTR _eflags$[esp+76]
	lea	ecx, DWORD PTR [esi+146]
	push	-1
	or	bl, 146					; 00000092H
	push	ecx
	mov	BYTE PTR [esi+87], bl
	mov	DWORD PTR [esi+52], edx
	mov	DWORD PTR [esi+64], ebp
	mov	DWORD PTR [esi+60], eax
	call	?memset@@YAPAXPAXDI@Z			; memset

; 148  : 
; 149  : 		p_proc->nr_tty = 0;
; 150  : 
; 151  : 		p_proc->p_flags = 0;
; 152  : 
; 153  : 		p_task_stack -= p_task->stack_size;

	sub	ebp, DWORD PTR [edi+4]

; 154  : 		p_proc ++;
; 155  : 		p_task ++;
; 156  : 		selector_ldt += (1 << 3);

	mov	edi, DWORD PTR tv445[esp+84]
	xor	eax, eax
	mov	DWORD PTR [esi+114], eax
	mov	DWORD PTR [esi+118], eax
	mov	eax, DWORD PTR _i$[esp+84]
	add	esp, 44					; 0000002cH
	add	esi, 194				; 000000c2H
	add	DWORD PTR _selector_ldt$[esp+40], 8
$LN5@init_proc:
	add	DWORD PTR tv438[esp+40], 28		; 0000001cH
	add	edi, 28					; 0000001cH
	add	eax, 1
	cmp	edi, OFFSET ?user_proc_table@@3PAU_tagTASK@@A+896
	mov	DWORD PTR _i$[esp+40], eax
	mov	DWORD PTR tv445[esp+40], edi
	jl	$LL6@init_proc
	pop	edi
	pop	esi
	pop	ebp

; 157  : 	}
; 158  : 
; 159  : 	proc_table[5].nr_tty = 1;

	mov	DWORD PTR ?proc_table@@3PAU_tagPROC@@A+1084, 1

; 160  : 
; 161  : 	p_proc_ready = proc_table;

	mov	DWORD PTR ?p_proc_ready@@3PAU_tagPROC@@A, OFFSET ?proc_table@@3PAU_tagPROC@@A ; p_proc_ready, proc_table
	pop	ebx

; 162  : }

	add	esp, 24					; 00000018H
	ret	0
?init_proc@@YAXXZ ENDP					; init_proc
_TEXT	ENDS
PUBLIC	?clock_handler@@YAXH@Z				; clock_handler
; Function compile flags: /Ogtpy
;	COMDAT ?clock_handler@@YAXH@Z
_TEXT	SEGMENT
_irq$ = 8						; size = 4
?clock_handler@@YAXH@Z PROC				; clock_handler, COMDAT

; 320  : 	ticks ++;

	add	DWORD PTR ?ticks@@3IA, 1		; ticks

; 321  : 	if(k_reenter != 0){

	cmp	DWORD PTR ?k_reenter@@3HA, 0		; k_reenter
	jne	SHORT $LN2@clock_hand

; 322  : 		return;
; 323  : 	}
; 324  : 	schedule();

	jmp	?schedule@@YAXXZ			; schedule
$LN2@clock_hand:

; 325  : }

	ret	0
?clock_handler@@YAXH@Z ENDP				; clock_handler
_TEXT	ENDS
PUBLIC	?clock_irq@@YAXXZ				; clock_irq
; Function compile flags: /Ogtpy
;	COMDAT ?clock_irq@@YAXXZ
_TEXT	SEGMENT
?clock_irq@@YAXXZ PROC					; clock_irq, COMDAT

; 297  : 	save();

	sub	esp, 4
	pushad
	call	?_save@@YAXXZ				; _save

; 298  : 	//	save registers
; 299  : 	_asm{
; 300  : 		in	al,INT_M_CTLMASK

	in	al, 33					; 00000021H

; 301  : 		or	al,1

	or	al, 1

; 302  : 		out	INT_M_CTLMASK,al

	out	33, al					; 00000021H

; 303  : 
; 304  : 		mov al,EOI

	mov	al, 32					; 00000020H

; 305  : 		out INT_M_CTL,al

	out	32, al					; 00000020H

; 306  : 	}
; 307  : 	_asm sti

	sti

; 308  : 	clock_handler(0);					//	handle clock irq

	add	DWORD PTR ?ticks@@3IA, 1		; ticks
	cmp	DWORD PTR ?k_reenter@@3HA, 0		; k_reenter
	jne	SHORT $LN4@clock_irq
	call	?schedule@@YAXXZ			; schedule
$LN4@clock_irq:

; 309  : 	_asm cli

	cli

; 310  : 	_asm{
; 311  : 		in	al,INT_M_CTLMASK

	in	al, 33					; 00000021H

; 312  : 		and	al,0xfe

	and	al, -2					; fffffffeH

; 313  : 		out	INT_M_CTLMASK,al

	out	33, al					; 00000021H

; 314  : 	}
; 315  : 	_asm ret

	ret	0
?clock_irq@@YAXXZ ENDP					; clock_irq
_TEXT	ENDS
PUBLIC	?i86_initialize_clock_irq@@YAHXZ		; i86_initialize_clock_irq
EXTRN	?out_byte@@YAXGE@Z:PROC				; out_byte
EXTRN	?in_byte@@YAEG@Z:PROC				; in_byte
EXTRN	?setvect@@YAXHP6AXXZ@Z:PROC			; setvect
; Function compile flags: /Ogtpy
;	COMDAT ?i86_initialize_clock_irq@@YAHXZ
_TEXT	SEGMENT
_state$ = -4						; size = 1
?i86_initialize_clock_irq@@YAHXZ PROC			; i86_initialize_clock_irq, COMDAT

; 199  : {

	push	ecx

; 200  : 	uint8_t	state;
; 201  : 	setvect(32,clock_irq);

	push	OFFSET ?clock_irq@@YAXXZ		; clock_irq
	push	32					; 00000020H
	call	?setvect@@YAXHP6AXXZ@Z			; setvect

; 202  : 
; 203  : 	//out_byte(TIMER_MODE,RATE_GENERATOR);
; 204  : 	//out_byte(TIMER0,(uint8_t)(TIMER_FREQ / HZ));
; 205  : 	//out_byte(TIMER0,(uint8_t)(TIMER_FREQ / HZ) >> 8);
; 206  : 
; 207  : 	state = in_byte(INT_M_CTLMASK);

	push	33					; 00000021H
	call	?in_byte@@YAEG@Z			; in_byte

; 208  : 	state &= 0xfe;

	and	al, 254					; 000000feH
	mov	BYTE PTR _state$[esp+16], al

; 209  : 	//	master OCW1
; 210  : 	out_byte(INT_M_CTLMASK,state);

	mov	eax, DWORD PTR _state$[esp+16]
	push	eax
	push	33					; 00000021H
	call	?out_byte@@YAXGE@Z			; out_byte

; 211  : 	return 0;

	xor	eax, eax

; 212  : }

	add	esp, 24					; 00000018H
	ret	0
?i86_initialize_clock_irq@@YAHXZ ENDP			; i86_initialize_clock_irq
_TEXT	ENDS
END
