; Listing generated by Microsoft (R) Optimizing Compiler Version 14.00.50727.762 

	TITLE	i:\os\10\a\krnl\krnl\string.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMT
INCLUDELIB OLDNAMES

PUBLIC	?strcpy@@YAPADPADPBD@Z				; strcpy
; Function compile flags: /Ogtpy
; File i:\os\10\a\krnl\krnl\string.cpp
;	COMDAT ?strcpy@@YAPADPADPBD@Z
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_src$ = 12						; size = 4
?strcpy@@YAPADPADPBD@Z PROC				; strcpy, COMDAT

; 5    : 	char* s1_p = dest;

	mov	edx, DWORD PTR _dest$[esp-4]
	push	esi
	mov	esi, DWORD PTR _src$[esp]
	mov	eax, edx
	npad	5
$LL2@strcpy:

; 6    : 	while(*dest++ = *src++);

	mov	cl, BYTE PTR [esi]
	mov	BYTE PTR [edx], cl
	add	edx, 1
	add	esi, 1
	test	cl, cl
	jne	SHORT $LL2@strcpy
	pop	esi

; 7    : 	return s1_p;
; 8    : }

	ret	0
?strcpy@@YAPADPADPBD@Z ENDP				; strcpy
_TEXT	ENDS
PUBLIC	?strlen@@YAIPBD@Z				; strlen
; Function compile flags: /Ogtpy
;	COMDAT ?strlen@@YAIPBD@Z
_TEXT	SEGMENT
_str$ = 8						; size = 4
?strlen@@YAIPBD@Z PROC					; strlen, COMDAT

; 12   : 	size_t len = 0;

	mov	ecx, DWORD PTR _str$[esp-4]
	xor	eax, eax
$LL2@strlen:

; 13   : 	while(str[len++]);

	mov	dl, BYTE PTR [eax+ecx]
	add	eax, 1
	test	dl, dl
	jne	SHORT $LL2@strlen

; 14   : 	return len;
; 15   : }

	ret	0
?strlen@@YAIPBD@Z ENDP					; strlen
_TEXT	ENDS
PUBLIC	?strcmp@@YAHPBD0@Z				; strcmp
; Function compile flags: /Ogtpy
;	COMDAT ?strcmp@@YAHPBD0@Z
_TEXT	SEGMENT
_str1$ = 8						; size = 4
_str2$ = 12						; size = 4
?strcmp@@YAHPBD0@Z PROC					; strcmp, COMDAT

; 19   : 	int res = 0;
; 20   : 	while(!(res = *(unsigned char *)str1 - *(unsigned char *)str2 ) && *str2){

	mov	edx, DWORD PTR _str1$[esp-4]
	movzx	eax, BYTE PTR [edx]
	push	esi
	mov	esi, DWORD PTR _str2$[esp]
	mov	cl, BYTE PTR [esi]
	push	edi
	movzx	edi, cl
	sub	eax, edi
	jne	SHORT $LN3@strcmp
$LL4@strcmp:
	test	cl, cl
	je	SHORT $LN3@strcmp
	mov	cl, BYTE PTR [esi+1]
	movzx	eax, BYTE PTR [edx+1]

; 21   : 		++str1;++str2;

	add	esi, 1
	add	edx, 1
	movzx	edi, cl
	sub	eax, edi
	je	SHORT $LL4@strcmp
$LN3@strcmp:

; 22   : 	}
; 23   : 	if(res < 0)

	test	eax, eax
	pop	edi
	pop	esi
	jge	SHORT $LN10@strcmp

; 24   : 		res = -1;

	or	eax, -1

; 27   : 	return res;
; 28   : }

	ret	0
$LN10@strcmp:

; 25   : 	if(res > 0)

	jle	SHORT $LN1@strcmp

; 26   : 		res = 1;

	mov	eax, 1
$LN1@strcmp:

; 27   : 	return res;
; 28   : }

	ret	0
?strcmp@@YAHPBD0@Z ENDP					; strcmp
_TEXT	ENDS
PUBLIC	?memcpy@@YAPAXPAXPBXI@Z				; memcpy
; Function compile flags: /Ogtpy
;	COMDAT ?memcpy@@YAPAXPAXPBXI@Z
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_src$ = 12						; size = 4
_count$ = 16						; size = 4
?memcpy@@YAPAXPAXPBXI@Z PROC				; memcpy, COMDAT

; 32   : 	const char* sp = (const char*)src;

	mov	ecx, DWORD PTR _src$[esp-4]
	push	esi

; 33   : 	char* dp = (char*) dest;
; 34   : 	for(;count!=0;count--)*dp++ = *sp++;

	mov	esi, DWORD PTR _count$[esp]
	test	esi, esi
	je	SHORT $LN8@memcpy
	push	edi
	mov	edi, DWORD PTR _dest$[esp+4]
	mov	edx, edi
	sub	edx, ecx
$LL3@memcpy:
	mov	al, BYTE PTR [ecx]
	mov	BYTE PTR [edx+ecx], al
	add	ecx, 1
	sub	esi, 1
	jne	SHORT $LL3@memcpy

; 35   : 	return dest;

	mov	eax, edi
	pop	edi
	pop	esi

; 36   : }

	ret	0
$LN8@memcpy:

; 35   : 	return dest;

	mov	eax, DWORD PTR _dest$[esp]
	pop	esi

; 36   : }

	ret	0
?memcpy@@YAPAXPAXPBXI@Z ENDP				; memcpy
_TEXT	ENDS
PUBLIC	?memset@@YAPAXPAXDI@Z				; memset
; Function compile flags: /Ogtpy
;	COMDAT ?memset@@YAPAXPAXDI@Z
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_val$ = 12						; size = 1
_count$ = 16						; size = 4
?memset@@YAPAXPAXDI@Z PROC				; memset, COMDAT

; 40   : 	unsigned char* tmp = (unsigned char *)dest;
; 41   : 	for(;count!=0;count--,tmp[count] = val);

	mov	ecx, DWORD PTR _count$[esp-4]
	test	ecx, ecx
	mov	eax, DWORD PTR _dest$[esp-4]
	je	SHORT $LN1@memset
	mov	dl, BYTE PTR _val$[esp-4]
$LL3@memset:
	sub	ecx, 1
	mov	BYTE PTR [eax+ecx], dl
	jne	SHORT $LL3@memset
$LN1@memset:

; 42   : 	return dest;
; 43   : }

	ret	0
?memset@@YAPAXPAXDI@Z ENDP				; memset
_TEXT	ENDS
PUBLIC	?memsetw@@YAPAGPAGGI@Z				; memsetw
; Function compile flags: /Ogtpy
;	COMDAT ?memsetw@@YAPAGPAGGI@Z
_TEXT	SEGMENT
_dest$ = 8						; size = 4
_val$ = 12						; size = 2
_count$ = 16						; size = 4
?memsetw@@YAPAGPAGGI@Z PROC				; memsetw, COMDAT

; 47   : 	unsigned short *tmp = (unsigned short *)dest;
; 48   : 	for(; count!=0;count--)*tmp++ = val;

	mov	ecx, DWORD PTR _count$[esp-4]
	test	ecx, ecx
	je	SHORT $LN8@memsetw
	mov	eax, DWORD PTR _val$[esp-4]
	mov	edx, DWORD PTR _dest$[esp-4]
	push	esi
	mov	si, ax
	push	edi
	mov	edi, edx
	shl	esi, 16					; 00000010H
	mov	si, ax
	shr	ecx, 1
	mov	eax, esi
	rep stosd
	adc	ecx, ecx
	rep stosw
	pop	edi

; 49   : 	return dest;

	mov	eax, edx
	pop	esi

; 50   : }

	ret	0
$LN8@memsetw:

; 49   : 	return dest;

	mov	eax, DWORD PTR _dest$[esp-4]

; 50   : }

	ret	0
?memsetw@@YAPAGPAGGI@Z ENDP				; memsetw
_TEXT	ENDS
PUBLIC	?strchr@@YAPADPADH@Z				; strchr
; Function compile flags: /Ogtpy
;	COMDAT ?strchr@@YAPADPADH@Z
_TEXT	SEGMENT
_str$ = 8						; size = 4
_character$ = 12					; size = 4
?strchr@@YAPADPADH@Z PROC				; strchr, COMDAT

; 53   : {

	mov	edx, DWORD PTR _character$[esp-4]
	mov	eax, DWORD PTR _str$[esp-4]
	push	esi
	npad	7
$LL4@strchr:

; 54   : 	do{
; 55   : 		if(*str == character){

	mov	cl, BYTE PTR [eax]
	movsx	esi, cl
	cmp	esi, edx
	je	SHORT $LN5@strchr

; 56   : 			return (char*)str;
; 57   : 		}
; 58   : 	}
; 59   : 	while(*str++);

	add	eax, 1
	test	cl, cl
	jne	SHORT $LL4@strchr

; 60   : 	return 0;

	xor	eax, eax
$LN5@strchr:
	pop	esi

; 61   : }

	ret	0
?strchr@@YAPADPADH@Z ENDP				; strchr
_TEXT	ENDS
END
